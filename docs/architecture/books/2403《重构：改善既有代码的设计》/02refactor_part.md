# 07-12

## 7. 封装

### 7.1 封装记录（Encapsulate Record）

![](https://img.zhengyua.cn/blog/202406040913894.png)

- **有意义的单元传递**

记录型结构是多数编程语言提供的一种常见特性。它们能直观地组织起存在关联的数据，让我可以将数据作为有意义的单元传递，而不仅是一堆数据的拼凑。

- **对象可隐藏结构细节和帮助字段改名**

对象可以隐藏其内部结构细节，隐藏结构的细节。该对象的用户不必追究存储的细节和计算的过程。同时这种封装还有助于字段的改名：可重新命名字段，但同时提供新老字段名的访问方法，这样可以渐进地修改调用方，直到替换全部完成。

- **数据结构直观**

若这种记录只在程序的一个小范围里使用，那问题还不大，但若其使用范围变宽，“数据结构不直观”这个问题就会造成更多困扰。可以重构它，使其变得更直观——但如果真需要这样做，那还不如使用类来得直接。

- **嵌套结构也值得封装**

程序中间常常需要互相传递嵌套的列表或散列映射结构，这些数据结构后续经常需要被序列化成JSON或XML。这样的嵌套结构同样值得封装，这样如果后续其结构需要变更或者需要修改记录内的值，封装能够帮更好地应对变化。

??? note "具体重构步骤"

	1. 对持有记录的变量使用封装变量，将其封装到一个函数中；

	> 记得为这个函数取一个容易搜索的名字。

	2. 创建一个类，将记录包装起来，并将记录变量的值替换为该类的一个实例。然后在类上定义一个访问函数，用于返回原始的记录。修改封装变量的函数，令其使用这个访问函数；
	
	3. 测试;

	4. 新建一个函数，让它返回该类的对象，而非那条原始的记录；

	5. 对于该记录的每处使用点，将原先返回记录的函数调用替换为那个返回实例对象的函数调用。使用对象上的访问函数来获取数据的字段，如果该字段的访问函数还不存在，那就创建一个。每次更改之后运行测试；

	> 如果该记录比较复杂，例如是个嵌套解构，那么先重点关注客户端对数据的更新操作，对于读取操作可以考虑返回一个数据副本或只读的数据代理。

	6. 移除类对原始记录的访问函数，那个容易搜索的返回原始数据的函数也要一并删除；

	7. 测试；

	8. 如果记录中的字段本身也是复杂结构，考虑对其再次应用封装记录或封装集合手法；

### 7.2 封装集合（Encapsulate Collection） 

![](https://img.zhengyua.cn/blog/202406040919805.png)

- **清晰观测数据修改**

封装程序中的所有可变数据可以让我们容易看清楚数据被修改的地点和修改方式，这样需要更改数据结构时就非常方便。

- **只对集合变量访问封装的问题**

封装集合时人们常常犯一个错误即只对集合变量的访问进行了封装，但依然让取值函数返回集合本身。这使得集合的成员变量可以直接被修改，而封装它的类则全然不知，无法介入。

- **注意集合取值函数返回**

更好的做法是，不要让集合的取值函数返回原始集合，这就避免了客户端的意外修改。

- **直接返回集合值的问题**

一种避免直接修改集合的方法是，永远不直接返回集合的值。这种方法提倡，不要直接使用集合的字段，而是通过定义类上的方法来代替。

增加使用特殊的类方法来处理这些场景，会增加许多额外代码，使集合操作容易组合的特性大打折扣。

- **限制集合的访问权**

以某种形式限制集合的访问权，只允许对集合进行读操作。

- **提供取值函数**

最常见的做法是，为集合提供一个取值函数，但令其返回一个集合的副本。这样即使有人修改了副本，被封装的集合也不会受到影响。

- **保持一致**

采用哪种方法并无定式，最重要的是在同个代码库中做法要保持一致。建议只用一种方案，这样每个人都能很快习惯它，并在每次调用集合的访问函数时期望相同的行为。

??? note "具体重构步骤"

	1. 如果集合的引用尚未被封装起来，先用封装变量封装它；

	2. 在类上添加用于“添加集合元素”和“移除集合元素”的函数；

	> 如果存在对该集合的设值函数，尽可能先用移除设值函数移除它。如果不能移除该设值函数，至少让它返回集合的一份副本。

	3. 执行静态检查；

	4. 查找集合的引用点。如果有调用者直接修改集合，令该处调用使用新的添加/移除元素的函数。每次修改后执行测试；

	5. 修改集合的取值函数，使其返回一份只读的数据，可以使用只读代理或数据副本；

	6. 测试；

### 7.3 以对象取代基本类型（Replace Primitive with Object）

![](https://img.zhengyua.cn/blog/202406040936656.png)

- **数据操作拓展**

一旦发现对某个数据的操作不仅仅局限于打印时，我就会为它创建一个新类。一开始这个类也许只是简单包装一下简单类型的数据，不过只要类有了，日后添加的业务逻辑就有地可去了。


??? note "具体重构步骤"

	1. 如果变量尚未被封装起来，先使用封装变量封装它；

	2. 为这个数据值创建一个简单的类。类的构造函数应该保存这个数据值，并为它提供一个取值函数；

	3. 执行静态检查；

	4. 修改第一步得到的设值函数，令其创建一个新类的对象并将其存入字段，如果有必要的话，同时修改字段的类型声明；

	5. 修改取值函数，令其调用新类的取值函数，并返回结果；

	6. 测试；

	7. 考虑对第一步得到的访问函数使用函数改名，以便更好反映其用途；

	8. 考虑应用将引用对象改为值对象或将值对象改为引用对象，明确指出新对象的角色是值对象还是引用对象；

### 7.4 以查询取代临时变量（Replace Templ with Query）

![](https://img.zhengyua.cn/blog/202406040940191.png)

- **设立清晰的边界**

如果正在分解一个冗长的函数，那么将变量抽取到函数里能使函数的分解过程更简单，因为这样就不再需要将变量作为参数传递给提炼出来的小函数。

将变量的计算逻辑放到函数中，也有助于在提炼得到的函数与原函数之间设立清晰的边界，这能帮助发现并避免难缠的依赖及副作用。

- **避免重复编写计算逻辑**

改用函数还可以避免了在多个函数中重复编写计算逻辑。每当在不同的地方看见同一段变量的计算逻辑，可以尝试将它们挪到同一个函数里。

- **快照用途的临时变量**

最简单的情况是，这个临时变量只被赋值一次，但在更复杂的代码片段里，变量也可能被多次赋值——此时应该将这些计算代码一并提炼到查询函数中。并且，待提炼的逻辑多次计算同样的变量时，应该能得到相同的结果。因此，对于那些做快照用途的临时变量（从变量名往往可见端倪）就不能使用本手法。

??? note "具体重构步骤"

	1. 检查变量在使用前是否已经完全计算完毕，检查计算它的那段代码是否每次都能得到一样的值；

	2. 如果变量目前不是只读的，但是可以改造成只读变量，那就先改造它；

	3. 测试；

	4. 将为变量赋值的代码段提炼成函数；

	> 如果变量和函数不能使用同样的名字，那么先为函数取个临时的名字。确保待提炼函数没有副作用。若有先应用将查询函数和修改函数分离手法隔离副作用。

	5. 测试；

	6. 应用内联变量手法移除临时变量；

### 7.5 提炼类（Extract Class）

![](https://img.zhengyua.cn/blog/202406040950654.png)

- **类不断成长扩展**

在实际工作中，类会不断成长扩展。随着责任不断增加，这个类会变得过分复杂。

- **大类的维护**

维护大量函数和数据的的类往往因为太大而不易理解。此时需要考虑哪些部分可以分离出去，并将它们分离到一个独立的类中。

如果某些数据和某些函数总是一起出现，某些数据经常同时变化甚至彼此相依，这就表示你应该将它们分离出去。

- **类的子类化**

如果发现子类化只影响类的部分特性，或发现某些特性需要以一种方式来子类化，某些特性则需要以另一种方式子类化，这就意味着需要分解原来的类。

??? note "具体重构步骤"
	
	1. 决定如何分解类所负的责任；

	2. 创建一个新的类，用以表现从旧类中分离出来的责任；

	> 如果旧类剩下的责任与旧类的名称不符，为旧类改名。

	3. 构造旧类时创建一个新类的实例，建立“从旧类访问新类”的连接关系；

	4. 对于你想搬移的每一个字段，运用搬移字段搬移之。每次更改后运行测试；

	5. 使用搬移函数将必要函数搬移到新类。先搬移较低层函数。每次更改后运行测试；

	6. 检查两个类的接口，去掉不再需要的函数，必要时为函数重新取一个适合新环境的名字；

	7. 决定是否公开新的类。如果确实需要，考虑对新类应用将引用对象改为值对象使其成为一个值对象；

### 7.6 内联类（Inline Class）

![](https://img.zhengyua.cn/blog/202406040955411.png)

- **不承担责任的类**

内联类正好与提炼类相反。如果一个类不再承担足够责任，不再有单独存在的理由（这通常是因为此前的重构动作移走了这个类的责任）。

- **重新安排职责**

若想重新安排两个类的职责，并让它们产生关联。此时先将它们内联成一个类再用提炼类去分离其职责会更加简单。

??? note "具体重构步骤"

	1. 对于待内联类（源类）中的所有public函数，在目标类上创建一个对应的函数，新创建的所有函数应该直接委托至源类；

	2. 修改源类public方法的所有引用点，令它们调用目标类对应的委托方法。每次更改后运行测试；

	3. 将源类中的函数与数据全部搬移到目标类，每次修改之后进行测试，直到源类 变成空壳为止；

	4. 删除源类，为它举行一个简单的“丧礼”；

### 7.7 隐藏委托关系（Hide Delegate）

![](https://img.zhengyua.cn/blog/202406051019653.png)

- **好的模块化设计**

一个好的模块化的设计，“封装”即使不是其最关键特征，也是最关键特征之一。“封装”意味着每个模块都应该尽可能少了解系统的其他部分。

- **去除委托依赖**

如果某些客户端先通过服务对象的字段得到另一个对象（受托类），然后调用后者的函数，那么客户就必须知晓这一层委托关系。 万一受托类修改了接口，变化会波及通过服务对象使用它的所有客户端。

可以在服务对象上放置一个简单的委托函数，将委托关系隐藏起来，从而去除这种依赖。这么一来，即使将来委托关系发生变化，变化也只会影响服务对象，而不会直接波及所有客户端。

![](https://img.zhengyua.cn/blog/202406051021566.png)

??? note "具体重构步骤"

	1. 对于每个委托关系中的函数，在服务对象端建立一个简单的委托函数；

	2. 调整客户端，令它只调用服务对象提供的函数。每次调整后运行测；

	3. 如果将来不再有任何客户端需要取用 Delegate（受托类），便可移除服务对象 中的相关访问函数。

	4. 测试；

### 7.8 移除中间人（Remove Middle Man）

![](https://img.zhengyua.cn/blog/202406051023383.png)

- **封装的代价**

每当客户端要使用受托类的新特性时，就必须在服务端添加一个简单委托函数。随着受托类的特性越来越多，更多的转发函数会让服务类完全变成了一个中间人，此时就应该让客户直接调用受托类。

- **合适的隐藏程度**

随着代码的变化，“合适的隐藏程度”这个尺度也相应改变。

??? note "具体重构步骤"

	1. 为受托对象创建一个取值函数；

	2. 对于每个委托函数，让其客户端转为连续的访问函数调用。每次替换后运行测试；

	> 替换完委托方法的所有调用点后，就可以删掉这个委托方法了。
	>
	> 这能通过可自动化的重构手法来完成，你可以先对受托字段使用封装变量，再应用内联函数内联所有使用它的函数。

### 7.9 替换算法（Substitute Algorithm）

![](https://img.zhengyua.cn/blog/202406051027265.png)

- **更简单的解决方案**

随着对问题有了更多理解，可能会发现在原先的做法之外，有更简单的解决方案，此时就需要改变原先的算法。

- **替换算法的困难**

替换一个巨大且复杂的算法是非常困难的，只有先将它分解为较简单的小型函数，才能很有把握地进行算法替换工作。

??? note "具体重构步骤"

	1. 整理一下待替换的算法，保证它已经被抽取到一个独立的函数中；

	2. 先只为这个函数准备测试，以便固定它的行为；

	3. 准备好另一个（替换用）算法；

	4. 执行静态检查；

	5. 运行测试，比对新旧算法的运行结果。如果测试通过，那就大功告成；否则在后续测试和调试过程中，以旧算法为比较参照标准；

## 8. 搬移特性

## 9. 重新组织数据

## 10. 简化条件逻辑

## 11. 重构 API

## 12. 处理继承关系
