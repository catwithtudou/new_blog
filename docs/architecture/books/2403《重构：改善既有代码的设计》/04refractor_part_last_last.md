# 11-12

## 11. 重构 API

### 11.1 将查询函数和修改函数分离（Separate Query from Modifier）

![](https://img.zhengyua.cn/blog/202406091443022.png)

- **没有副作用的函数**

如果某个函数只是提供一个值，没有任何看得到的副作用，那么这是一个很有价值的东西。我可以任意调用这个函数，也可以把调用动作搬到调用函数的其他地方。

- **命令与查询分离**

任何有返回值的函数，都不应该有看得到的副作用——命令与查询分离（Command-Query Separation）。

??? note "具体重构步骤"

	1. 复制整个函数，将其作为一个查询来命名；

	> 如果想不出好名字，可以看看函数返回的是什么。查询的结果会被填入一个变量，这个变量的名字应该能对函数如何命名有所启发。

	2. 从新建的查询函数中去掉所有造成副作用的语句；
	3. 执行静态检查；
	4. 查找所有调用原函数的地方。如果调用处用到了该函数的返回值，就将其改为调用新建的查询函数，并在下面马上再调用一次原函数。每次修改之后都要测试；
	5. 从原函数中去掉返回值；
	6. 测试；
	
	> 完成重构之后，查询函数与原函数之间常会有重复代码，可以做必要的清理。
 

### 11.2 函数参数化（Parameterize Function）

![](https://img.zhengyua.cn/blog/202406091446449.png)

- **合并函数消除重复**

若发现两个函数逻辑非常相似，只有一些字面量值不同，可以将其合并成一个函数，以参数的形式传入不同的值，从而消除重复。

这个重构可以使函数更有用，因为重构后的函数还可以用于处理其他的值。

??? note "具体重构步骤"

	1. 从一组相似的函数中选择一个；
	2. 运用改变函数声明。把需要作为参数传入的字面量添加到参数列表中；
	3. 修改该函数所有的调用处，使其在调用时传入该字面量值；
	4. 测试；
	5. 修改函数体，令其使用新传入的参数。每使用一个新参数都要测试；
	6. 对于其他与之相似的函数，逐一将其调用处改为调用已经参数化的函数。每次修改后都要测试；

	> 如果第一个函数经过参数化以后不能直接替代另一个与之相似的函数，先对参数化之后的函数做必要的调整，再做替换。


### 11.3 移除标记参数（Remove Flag Argument）

![](https://img.zhengyua.cn/blog/202406091449336.png)

- **标记参数**

“标记参数”是这样的一种参数：调用者用它来指示被调函数应该执行哪一部分逻辑。

- **隐藏差异性**

标记参数让人难以理解到底有哪些函数可以调用、应该怎么调用。拿到一份API以后，首先看到的是一系列可供调用的函数，但标记参数却隐藏了函数调用中存在的差异性。

- **直接传入字面值**

并非所有类似这样的参数都是标记参数。如果调用者传入的是程序中流动的数据，这样的参数不算标记参数；只有调用者直接传入字面量值，这才是标记参数。

- **使代码更整洁**

移除标记参数不仅使代码更整洁，并且能帮助开发工具更好地发挥作用。去掉标记参数后，代码分析工具能更容易地体现出“高级”和“普通”两种预订逻辑在使用时的区别。

??? note "具体重构步骤"

	1. 针对参数的每一种可能值，新建一个明确函数；

	> 如果主函数有清晰的条件分发逻辑，可以用分解条件表达式(260)创建 明确函数;否则，可以在原函数之上创建包装函数。

	2. 对于“用字面量值作为参数”的函数调用者，将其改为调用新建的明确函数；


### 11.4 保持对象完整（Preserve Whole Object）

![](https://img.zhengyua.cn/blog/202406091453111.png)

- **传递整个记录**

“传递整个记录”的方式能更好地应对变化：如果将来被调的函数需要从记录中导出更多的数据，就不用为此修改参数列表。并且传递整个记录也能缩短参数列表，让函数调用更容易看懂。

- **依恋情结**

从一个对象中抽取出几个值，单独对这几个值做某些逻辑操作，这是一种代码坏味道（依恋情结），通常标志着这段逻辑应该被搬移到对象中。

- **提炼类的时机**

如果几处代码都在使用对象的一部分功能，可能意味着应该用提炼类把这一部分功能单独提炼出来。

??? note "具体重构步骤"

	1. 新建一个空函数，给它以期望中的参数列表（即传入完整对象作为参数）；

	> 给这个函数起一个容易搜索的名字，这样到重构结束时方便替换。

	2. 在新函数体内调用旧函数，并把新的参数（即完整对象）映射到旧的参数列表（即来源于完整对象的各项数据）；
	3. 执行静态检查；
	4. 逐一修改旧函数的调用者，令其使用新函数，每次修改之后执行测试；

	> 修改之后，调用处用于“从完整对象中导出参数值”的代码可能就没用了，可以用移除死代码去掉。
	
	5. 所有调用处都修改过来之后，使用内联函数把旧函数内联到新函数体内；
	6. 给新函数改名，从重构开始时的容易搜索的临时名字，改为使用旧函数的名字，同时修改所有调用处；


### 11.5 以查询取代参数（Replace Parameter with Query）

![](https://img.zhengyua.cn/blog/202406091457527.png)

- **总结函数可变性的参数列表**

函数的参数列表应该总结该函数的可变性，标示出函数可能体现出行为差异的主要方式。和任何代码中的语句一样，参数列表应该尽量避免重复，并且参数列表越短就越容易理解。

- **不必要的参数会增加调用者的难度**

如果调用函数时传入了一个值，而这个值由函数自己来获得也是同样容易，这就是重复。这个本不必要的参数会增加调用者的难度，因为它不得不找出正确的参数值，其实原本调用者是不需要费这个力气的。

- **获得正确参数值的责任**

去除参数也就意味着“获得正确的参数值”的责任被转移：有参数传入时，调用者需要负责获得正确的参数值；参数去除后，责任就被转移给了函数本身。

- **移除参数带来的依赖关系**

不使用以查询取代参数最常见的原因是，移除参数可能会给函数体增加不必要的依赖关系——迫使函数访问某个程序元素，而我原本不想让函数了解这个元素的存在。

- **查询取代参数的安全场景**

如果想要去除的参数值只需要向另一个参数查询就能得到，这是使用以查询取代参数最安全的场景。如果可以从一个参数推导出另一个参数，那么几乎没有任何理由要同时传递这两个参数。

- **处理函数具有引用透明性**

如果在处理的函数具有引用透明性（referential transparency，即不论任何时候，只要传入相同的参数值，该函数的行为永远一致），这样的函数既容易理解又容易测试。通常不会去掉它的参数，让它去访问一个可变的全局变量。


??? note "具体重构步骤"

	1. 如果有必要，使用提炼函数将参数的计算过程提炼到一个独立的函数中；
	2. 将函数体内引用该参数的地方改为调用新建的函数。每次修改后执行测试；
	3. 全部替换完成后，使用改变函数声明将该参数去掉；



### 11.6 以参数取代查询（Replace Query with Parameter）

![](https://img.zhengyua.cn/blog/202406091503170.png)

- **权衡改变代码依赖关系**

需要使用本重构的情况大多源于我想要改变代码的依赖关系——为了让目标函数不再依赖于某个元素，即把这个元素的值以参数形式传递给该函数。

这里需要注意权衡：如果把所有依赖关系都变成参数，会导致参数列表冗长重复；如果作用域之间的共享太多，又会导致函数间依赖过度。

- **引用透明性带来的益处**
  
如果一个函数使用了另一个元素，而后者不具引用透明性，那么包含该元素的函数也就失去了引用透明性。只要把“不具引用透明性的元素”变成参数传入，函数就能重获引用透明性。 

虽然这样就把责任转移给了函数的调用者，但是具有引用透明性的模块能带来很多益处。

- **常见的设计模式**

在负责逻辑处理的模块中只有纯函数，其外再包裹处理 I/O 和其他可变元素的逻辑代码。借助以参数取代查询，可提纯程序的某些组成部分，使其更容易测试、更容易理解。

- **增加函数调用者的复杂度**

把查询变成参数以后，就迫使调用者必须弄清如何提供正确的参数值，这会增加函数调用者的复杂度，而在设计接口时通常更愿意让接口的消费者更容易使用。

??? note "具体重构步骤"

	1. 对执行查询操作的代码使用提炼变量，将其从函数体中分离出来；
	2. 现在函数体代码已经不再执行查询操作（而是使用前一步提炼出的变量），对这部分代码使用提炼函数；

	> 给提炼出的新函数起一个容易搜索的名字，以便稍后改名。
	
	3. 使用内联变量，消除刚才提炼出来的变量；
	4. 对原来的函数使用内联函数；
	5. 对新函数改名，改回原来函数的名字；


### 11.7 移除设置函数（Remove Settings Method）

![](https://img.zhengyua.cn/blog/202406091510913.png)

- **排除被修改的可能性**

该字段就只能在构造函数中赋值，我“不想让它被修改”的意图会更加清晰，并且可以排除其值被修改的可能性——这种可能性往往是非常大的。

- **清晰地表达意图**

去除设值函数，清晰地表达“构造之后不应该再更新字段值”的意图。


??? note "具体重构步骤"

	1. 如果构造函数尚无法得到想要设入字段的值，就使用改变函数声明将这个值以参数的形式传入构造函数。在构造函数中调用设值函数，对字段设值；
	
	> 如果想移除多个设值函数，可以一次性把它们的值都传入构造函数，这能简化后续步骤。

	2. 移除所有在构造函数之外对设值函数的调用，改为使用新的构造函数。每次修改之后都要测试；

	> 如果不能把“调用设值函数”替换为“创建一个新对象”（例如需要更新一个多处共享引用的对象），请放弃本重构。
	
	3. 使用内联函数消去设值函数。如果可能的话，把字段声明为不可变；
	4. 测试；


### 11.8 以工厂函数取代构造函数（Replace Constructor with Factory Function）

![](https://img.zhengyua.cn/blog/202406091513565.png)

- **构造函数的局限性**

但与一般的函数相比，构造函数又常 有一些丑陋的局限性。例如，Java的构造函数只能返回当前所调用类的实例，即无法根据环境或参数信息返回子类实例或代理对象；构造函数的名字是固定的，因此无法使用比默认名字更清晰的函数名；构造函数需要通过特殊的操作符来调用（在很多语言中是new关键字），所以在要求普通函数的场合就难以使用。

- **工厂函数不受限制**

工厂函数就不受这些限制。工厂函数的实现内部可以调用构造函数，但也可以换成别的方式实现。

??? note "具体重构步骤"
	
	1. 新建一个工厂函数，让它调用现有的构造函数；
	2. 将调用构造函数的代码改为调用工厂函数；
	3. 每修改一处，就执行测试；
	4. 尽量缩小构造函数的可见范围；

### 11.9 以命令取代函数（Replace Function with Command）

![](https://img.zhengyua.cn/blog/202406091515346.png)

- **命令对象**

函数，不管是独立函数，还是以方法形式附着在对象上的函数， 是程序设计的基本构造块。

不过，将函数封装成自己的对象有时也是一种有用的办法。这样的对象称之为“命令对象”（command object），或简称“命令”（command）。这种对象大多只服务于单一函数，获得对该函数的请求，执行该函数，就是这种对象存在的意义。

- **命令对象带来的好处**

与普通的函数相比，命令对象提供了更大的控制灵活性和更强的表达能力。除了函数调用本身，命令对象还可以支持附加的操作，例如撤销操作。

可通过命令对象提供的方法来设值命令的参数值，从而支持更丰富的生命周期管理能力。

可借助继承和钩子对函数行为加以定制。如果我所使用的编程语言支持对象但不支持函数作为一等公民，通过命令对象就可以给函数提供大部分相当于一等公民的能力。

同样，即便编程语言本身并不支持嵌套函数，也可借助命令对象的方法和字段把复杂的函数拆解开，而且在测试和调试过程中可以直接调用这些方法。

- **命令对象带来的复杂性取舍**

如果要在作为一等公民的函数和命令对象之间做个选择，通常都会选函数。只有特别需要命令对象提供的某种能力而普通的函数无法提供这种能力时，才会考虑使用命令对象。


??? note "具体重构步骤"

	1. 为想要包装的函数创建一个空的类，根据该函数的名字为其命名；
	2. 使用搬移函数把函数移到空的类里；
	
	> 保持原来的函数作为转发函数，至少保留到重构结束之前才删除。

	3. 遵循编程语言的命名规范来给命令对象起名。如果没有合适的命名规范，就给命令对象中负责实际执行命令的函数起一个通用的名字；
	4. 可考虑给每个参数创建一个字段，并在构造函数中添加对应的参数；


### 11.10 以函数取代命令（Replace Command with Function）

![](https://img.zhengyua.cn/blog/202406091520389.png)

- **命令对象提供的强大机制**

命令对象为处理复杂计算提供了强大的机制。借助命令对象，可以轻松地将原本复杂的函数拆解为多个方法，彼此之间通过字段共享状态；拆解后的方法可以分别调用；开始调用之前的数据状态也可以逐步构建。

- **不复杂使用的场景**

大多数时候只是想调用一个函数，让它完成自己的工作就好。若这个函数不是太复杂，那么命令对象可能显得费而不惠，那么就应该考虑将其变回普通的函数。

??? note "具体重构步骤"

	1. 运用提炼函数，把“创建并执行命令对象”的代码单独提炼到一个函数中；

	> 这一步会新建一个函数，最终这个函数会取代现在的命令对象。 

	2. 对命令对象在执行阶段用到的函数，逐一使用内联函数；
	
	> 如果被调用的函数有返回值，请先对调用处使用提炼变量，然后再使用内联函数。

	3. 使用改变函数声明，把构造函数的参数转移到执行函数；
	4. 对于所有的字段，在执行函数中找到引用它们的地方，并改为使用参数。每次修改后都要测试；
	5. 把“调用构造函数”和“调用执行函数”两步都内联到调用方（也就是最终要替换命令对象的那个函数）；
	6. 测试；
	7. 用移除死代码把命令类消去；

## 12. 处理继承关系