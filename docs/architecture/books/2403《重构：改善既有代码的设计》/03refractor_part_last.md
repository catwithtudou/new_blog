
# 09-12

## 9. 重新组织数据

### 9.1 拆分变量（Split Variable）

![](https://img.zhengyua.cn/blog/202406060911871.png)

- **自然被多次赋值**

变量有各种不同的用途，其中某些用途会很自然地导致临时变量被多次赋值。

- **承担多个责任的变量**

如果变量承担多个责任，它就应该被替换（分解）为多个变量，每个变量只承担一个责任。同一个变量承担两件不同的事情，会令代码阅读者糊涂。

??? note "具体重构步骤"

	1. 在待分解变量的声明及其第一次被赋值处，修改其名称；

	> 如果稍后的赋值语句是“i=i+某表达式形式”，意味着这是一个结果收集变量，就不要分解它。结果收集变量常用于累加、字符串拼接、写入流或者向集合添加元素。

	2. 如果可能的话，将新的变量声明为不可修改；
	3. 以该变量的第二次赋值动作为界，修改此前对该变量的所有引用，让它们引用新变量；
	4. 测试；
	5. 重复上述过程。每次都在声明处对变量改名，并修改下次赋值之前的引用，直至到达最后一处赋值；

### 9.2 字段改名（Rename Field）

![](https://img.zhengyua.cn/blog/202406060914069.png)

- **重要的命名**

命名很重要，对于程序中广泛使用的记录结构，其中字段的命名格外重要。数据结构对于帮助阅读者理解特别重要。

- **保持数据结构的整洁**

既然数据结构如此重要，就很有必要保持它们的整洁。一如既往地，若在一个软件上做的工作越多，对数据的理解就越深，所以很有必要把我加深的理解融入程序中。

??? note "具体重构步骤"

	1. 如果记录的作用域较小，可以直接修改所有该字段的代码，然后测试。后面的步骤就都不需要了；
	2. 如果记录还未封装，请先使用封装记录；
	3. 在对象内部对私有字段改名，对应调整内部访问该字段的函数；
	4. 测试；
	5. 如果构造函数的参数用了旧的字段名，运用改变函数声明将其改名；
	6. 运用函数改名给访问函数改名；

### 9.3 以查询取代派生变量（Replace Derived Variable with Query）

![](https://img.zhengyua.cn/blog/202406070819469.png)

- **错误源头之可变数据**

可变数据是软件中最大的错误源头之一。对数据的修改常常导致代码的各个部分以丑陋的形式互相耦合：在一处修改数据，却在另一处造成难以发现的破坏。

很多时候，完全去掉可变数据并不现实，但还是强烈建议:尽量把可变数据的作用域限制在最小范围。

- **可计算出的变量**

有些变量其实可以很容易地随时计算出来。若能去掉这些变量，也会有助于消除可变性。

计算常能更清晰地表达数据的含义，而且也避免了“源数据修改时忘了更新派生变量”的错误。

- **两种不同的编程风格**

“根据源数据生成新数据结构”的变换操作可以保持不变，即便可以将其替换为计算操作。

实际上，这是两种不同的编程风格：一种是对象风格，把一系列计算得出的属性包装在数据结构中；另一种是函数风格，将一个数据结构变换为另一个数据结构。

如果源数据会被修改，而必须负责管理派生数据结构的整个生命周期，那么对象风格显然更好。但如果源数据不可变，或者派生数据用过即弃，那么两种风格都可行。

??? note "具体重构步骤"

	1. 识别出所有对变量做更新的地方。如有必要，用拆分变量分割各个更新点；
	2. 新建一个函数，用于计算该变量的值；
	3. 用引入断言断言该变量和计算函数始终给出同样的值；
	
	> 如有必要，用封装变量将这个断言封装起来。
	
	4. 测试；
	5. 修改读取该变量的代码，令其调用新建的函数；
	6. 测试；
	7. 用移除死代码去掉变量的声明和赋值。

### 9.4 将引用对象改为值对象（Change Reference to Value）

![](https://img.zhengyua.cn/blog/202406070824778.png)

- **引用对象与值对象的差异**

在把一个对象（或数据结构）嵌入另一个对象时，位于内部的这个对象可以被视为引用对象，也可以被视为值对象。

两者最明显的差异在于如何更新内部对象的属性：如果将内部对象视为引用对象，在更新其属性时，我会保留原对象不动，更新内部对象的属性；如果将其视为值对象，我就会替换整个内部对象，新换上的对象会有我想要的属性值。

- **更容易理解的值对象不可变**

值对象通常更容易理解，主要因为它们是不可变的。

一般说来，不可变的数据结构处理起来更容易。可放心地把不可变的数据值传给程序的其他部分，而不必担心对象中包装的数据被偷偷修改。可在程序各处复制值对象，而不必操心维护内存链接。

值对象在分布式系统和并发系统中尤为有用。

- **共享对象的修改**

在几个对象之间共享一个对象，以便几个对象都能看见对共享对象的修改，那么这个共享的对象就应该是引用。

??? note "具体重构步骤"

	1. 检查重构目标是否为不可变对象，或者是否可修改为不可变对象；
	2. 用移除设值函数逐一去掉所有设值函数；
	3. 提供一个基于值的相等性判断函数，在其中使用值对象的字段；

	> 大多数编程语言都提供了可覆写的相等性判断函数。通常你还必须同时覆写生成散列码的函数。

### 9.5 将值对象改为引用对象（Change Value to Reference）

![](https://img.zhengyua.cn/blog/202406070827980.png)

- **复制多次带来的内存问题**

过多的数据复制有可能会造成内存占用的问题，但就跟所有性能问题一样，这种情况并不常见。

- **复制多份的局限**

如果共享的数据需要更新，将其复制多份的做法就会遇到巨大的困难。

此时必须找到所有的副本，更新所有对象。只要漏掉一个副本没有更新，就会遭遇麻烦的数据不一致。

- **某种形式的仓库**

把值对象改为引用对象会带来一个结果：对于一个客观实体，只有一个代表它的对象。

这通常意味着我会需要某种形式的仓库，在仓库中可以找到所有这些实体对象。只为每个实体创建一次对象，以后始终从仓库中获取该对象。

??? note "具体重构步骤"

	1. 为相关对象创建一个仓库(如果还没有这样一个仓库的话)；
	2. 确保构造函数有办法找到关联对象的正确实例；
	3. 修改宿主对象的构造函数，令其从仓库中获取关联对象。每次修改后执行测试。


## 10. 简化条件逻辑

## 11. 重构 API

## 12. 处理继承关系