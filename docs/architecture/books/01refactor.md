
# 2403 《重构：改善既有代码的设计》阅读

## 1. 重构，第一个示例

### 1.1 重点语句

**1. 程序添加特性前的考虑**

如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性。

**2.需求的变化使重构变得必要**

若代码能正常工作且不会再被修改（没有妨碍到任何人），则不用重构，但如果有人需要理解它的工作原理且觉得理解起来很费劲，则就需要改进代码了（妨碍他人了）。

**3. 重构前的第一步**

重构前，先检查自己是否有一套可靠的测试集。这些测试必须有自我检验能力。

**4. 重构技术的特点之一**

重构技术就是以微小的步伐（比如一开始的变量命名）修改程序。如果你犯下错误，很容易便可发现它。

**5. 优秀的程序员**

傻瓜都能写出计算机可以理解的代码。唯有能写出人类容易理解的代码的，才是优秀的程序员。

**6. 营地法则**

编程时，需要遵循营地法则:保证你离开时的代码库一定比来时更健康。

**7. 好代码的检验标准之一**

好代码的检验标准就是人们是否能轻而易举地修改它。


### 1.2 重构示例

**1. 重构示例使用到的重构手法**

- 提炼函数
- 内联变量
- 搬移函数
- 以多态取代条件表达式等

**2. 重构示例的关键节点**

- 第一步：将原函数「分解成一组嵌套的函数」
- 第二步：应用「拆分阶段」分离计算逻辑与输出格式化逻辑
- 第三步：为计算器「引入多态性」来处理计算逻辑


## 2. 重构的原则

### 2.1 何谓重构

**1. 重构的定义**

- 作为名词

对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

- 作为动词

使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。


**2. 简单识别重构的方法**

如果有人说他们的代码在重构过程中有一两天时间不可用，基本上可以确定，他们在做的事不是重构。

### 2.2 两顶帽子

**1. 两顶帽子**

- 帽子一：添加新功能

添加新功能时，不应该修改既有代码，只管添加新功能。通过添加测试并让测试正常运行，可以衡量工作进度。

- 帽子二：重构

重构时就不能再添加功能，只管调整代码的结构。此时不应该添加任何测试（除非发现有先前遗漏的东西），只在绝对必要（用以处理接口变化）时才修改测试。

**2. 无论何时得清楚戴的是哪一顶帽子，并明白不同的帽子对编程状态提出的不同要求**

### 2.3 为何重构

1. 重构改进软件的设计
2. 重构使软件更容易理解
3. 重构帮助找到 Bug
4. 重构提高编程速度

![](https://img.zhengyua.cn/blog/202403201227375.png)

### 2.4 何时重构

**1. 三次法则**

- 第一次做某件事时只管去做
- 第二次做类似的事会产生反感，但无论如何还是可以去做
- 第三次再做类似的事，你就应该重构

> 正如老话说的:事不过三，三则重构。

**2. 预备性重构：让添加新功能更加容易**

**3. 帮助理解的重构：使代码更易懂**

**4. 捡垃圾式重构**

**5. 有计划的重构和见机行事的重构**

肮脏的代码必须重构，但漂亮的代码也需要很多重构。

每次要修改时，首先令修改很容易（警告:这件事有时会很难），然后再进行这次容易的修改。

**6. 长期重构**

尽量让整个团队达成共识，来逐步解决重构的问题，而不建议一支团队专门做重构。

**7. 复审代码时重构**

**8. 怎么对经理说**

给团队一个较有争议的建议:不要告诉经理!

- 对于快速创造软件，重构可带来大帮助。如果需要添加新功能，而原本设计却又使我无法方便地修改，我发现先重构再添加新功能会更快些
- 如果要修补错误，就得先理解软件的工作方式，而我发现重构是理解软件的最快方式
- 受进度驱动的经理要我尽可能快速完成任务，至于怎么完成，那就是我的事了

**9. 何时不应该重构**

主要建议如下：

- 如果看见一块凌乱的代码，但并不需要修改它，那么就不需要重构它
- 如果重写比重构还容易，就别重构了

### 2.5 重构的挑战

**1. 延缓新功能的开发**

- 重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值
- 重构应该总是由经济利益驱动，重构的意义不在于把代码库打磨得闪闪发光，而是纯粹经济角度出发的考量，即之所以重构是因为它能让我们更快，添加功能和修复bug更快

**2. 代码所有权**

- 很多重构手法不仅会影响一个模块内部，还会影响该模块与系统其他部分的关系
- 可把旧的接口标记为“不推荐使用”(deprecated)，等一段时间之后最终让其退休；但有些时候，旧的接口必须一直保留下去
- 推荐团队代码所有制，这样一支团队里的成员都可以修改这个团队拥有的代码，即便最初写代码的是别人。这种较为宽容的代码所有制甚至可以应用于跨团队的场合

**3. 分支**

- 特性分支有其缺点，即在隔离的分支上工作得越久，将完成的工作集成(integrate)回主线就会越困难。为了减轻集成的痛苦，大多数人的办法是频繁地从主线合并(merge)或者变基(rebase)到分支
- 所以很多人认为，应该尽量缩短特性分支的生存周期，比如只有一两天。还有部分人认为应该更短，其采用的方法叫作持续集成(Continuous Integration，CI)，也叫“基于主干开发”(Trunk-Based Development)
- 并不是在说绝不应该使用特性分支，而是如果特性分支存在的时间足够短，它们就不会造成大问题(实际上，使用CI的团队往往同时也使用分支，但他们会每天将分支与主线合并)

**4. 测试**

- 不会改变程序可观察的行为，这是重构的一个重要特征
- 关键就在于“快速发现错误”，要做到这一点，其代码应该有一套完备的测试套件，并且运行速度要快，否则我会不愿意频繁运行它
- 如果没有自测试的代码，“重构风险太大，可能引入bug”的担忧是完全合理的，这也是为什么如此重视可靠的测试
- 缺乏测试的现状还催生了另一种重构的流派「只使用一组经过验证是安全的重构手法」。其要求严格遵循重构的每个步骤，并且可用的重构手法是特定于语言的。使用这种方法，团队得以在测试覆盖率很低的大型代码库上开展一些有用的重构

**5. 遗留代码**

- 重构可以很好地帮助理解遗留系统
- 需要运用重构手法创造出接缝，这样的重构很危险，因为没有测试覆盖，但这是为了取得进展必要的风险，而在这种情况下，安全的自动化重构简直就是天赐福音
- 就算有了测试，也不建议你尝试一鼓作气把复杂而混乱的遗留代码重构成漂亮的代码，而是更愿意随时重构相关的代码「每次触碰一块代码时，我会尝试把它变好一点点」

**6. 数据库**

- 一套渐进式数据库设计[mf-evodb]和数据库重构[Ambler & Sadalage]的办法，这项技术的精要在于「借助数据迁移脚本，将数据库结构的修改与代码相结合，使大规模的、涉及数据库的修改可以比较容易地开展」
- 与常规的重构不同，很多时候数据库重构最好是分散到多次生产发布来完成，这样即便某次修改在生产数据库上造成了问题，也比较容易回滚

### 2.6 重构、架构和YAGNI

**1. 重构对架构最大的影响**

- 在于通过重构，能得到一个设计良好的代码库，使其能够优雅地应对不断变化的需求

**2. 应对未来变化的办法之一**

- 就是在软件里植入灵活性机制
- 有了重构技术，可采取不同的策略。与其猜测未来需要哪些灵活性、需要什么机制来提供灵活性，我更愿意只根据当前的需求来构造软件，同时把软件的设计质量做得很高
- 但如果一种灵活性会增加软件复杂度，就必须先证明自己值得被引入

**3. YAGNI**

- “你不会需要它”(you arenʼt going to need it)的缩写，类似简单设计或增量式设计
- 把YAGNI视为将架构、设计与开发过程融合的一种工作方式，这种工作方式必须有重构作为基础才可靠
- 采用YAGNI并不表示完全不用预先考虑架构

### 2.7 重构与软件开发过程

- 如果一支团队想要重构，那么每个团队成员都需要掌握重构技能，能在需要时开展重构，而不会干扰其他人的工作
- 三大实践——自测试代码、持续集成、重构——彼此之间有着很强的协同效应，且有这三大核心实践打下的基础，才谈得上运用敏捷思想的其他部分

### 2.8 重构与性能

**1. 重构与性能**

- 我并不赞成为了提高设计的纯洁性而忽视性能，把希望寄托于更快的硬件身上也绝非正道
- 虽然重构可能使软件运行更慢，但它也使软件的性能优化更容易。除了对性能有严格要求的实时系统，其他任何情况下“编写快速软件”的秘密就是「先写出可调优的软件，然后调优它以求获得足够的速度」
- 哪怕你完全了解系统，也请实际度量它的性能，不要臆测。臆测会让你学到一些东西，但十有八九你是错的
- 短期看来，重构的确可能使软件变慢，但它使优化阶段的软件性能调优更容易，最终还是会得到好的效果

**2. 编写快速软件的方法**

- 最严格的是时间预算法。这通常只用于性能要求极高的实时系统，如果使用这种方法，分解你的设计时就要做好预算，给每个组件预先分配一定资源，包括时间和空间占用
- 持续关注法。这种方法要求任何程序员在任何时间做任何事时，都要设法保持系统的高性能

> 关于性能，一件很有趣的事情是：如果你对大多数程序进行分析，就会发现它把大半时间都耗费在一小半代码身上。如果你一视同仁地优化所有代码，90%的优化工作都是白费劲的，因为被你优化的代码大多很少被执行。

- 性能提升法。利用上述的90%统计数据，前期不对性能投以特别的关注，直至进入性能优化阶段


## 3. 代码的坏味道

**1. 神秘命名（Mysterious Name）**

!!! note "常用重构"

	**改变函数声明｜变量改名｜字段改名**

改名不仅仅是修改名字而已。如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题。为一个恼人的名字所付出的纠结，常常能推动我们对代码进行精简。

**2. 重复代码（Duplicated Code）**

!!! note "常用重构"

	**提炼函数｜移动语句｜函数上移**

一旦有重复代码存在，阅读这些重复的代码时你就必须加倍仔细，留意其间细微的差异。如果要修改重复代码，你必须找出所有的副本来修改。

**3. 过长函数（Long Function）**

!!! note "常用重构"

	**提炼函数｜查询取代临时变量｜引入参数对象｜保持对象完整｜以命令取代函数｜分解条件表达式｜以多态取代条件表达式｜拆分循环**

- 根据经验，活得最长、最好的程序，其中的函数都比较短
- 小函数的价值所在，间接性带来的好处——更好的阐释力、更易于分享、更多的选择——都是由小函数来支持的
- 固然，小函数也会给代码的阅读者带来一些负担，因为需要经常切换上下文，才能看明白函数在做什么。但现代的开发环境让你可以在函数的调用处与声明处之间快速跳转，或是同时看到这两处，让你根本不用来回跳转
- 让小函数易于理解的关键还是在于良好的命名。如果能给函数起个好名字，阅读代码的人就可以通过名字了解函数的作用，根本不必去看其中写了些什么
- 最终的效果是「你应该更积极地分解函数」。这里遵循这样一条原则「每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途(而非实现手法)命名」，关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离
- 如何确定该提炼哪一段代码呢?一个很好的技巧是「寻找注释」

**4. 过长参数列表（Long Parameter List）**

!!! note "常用重构"

	**查询取代参数｜保持对象完整｜引入参数对象｜移除标记参数｜函数组合成类**

过长的参数列表本身也经常令人迷惑。

**5. 全局数据（Global Data）**

!!! note "常用重构"

	**封装变量**

全局数据仍然是最刺鼻的坏味道之一。 全局数据的问题在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改。

> 全局数据印证了帕拉塞尔斯的格言:良药与毒药的区别在于剂量。

**6. 可变数据（Mutable Data）**


**7. 发散式变化（Divergent Change）**


**8. 霰弹式修改（Shotgun Surgery）**


**9. 依恋情结（Feature Envy）**


**10. 数据泥团（Data Clumps）**


**11. 基本类型偏执（Primitive Obsession）**


**12. 重复的（switch Repeated Switch）**


**13. 循环语句（Loops）**


**14. 冗赘的元素（Lazy Element）**


**15. 夸夸其谈通用性（Speculative Generality）**


**16. 临时字段（Temporary Field）**


**17. 过长的消息链（Message Chains）**


**18. 中间人（Middle Man）**


**19. 内幕交易（Insider Trading）**


**20. 过大的类（Large Class）**


**21. 异曲同工的类（Alternative Classes with Different Interfaces）**


**22. 纯数据类（Data Class）**


**23. 被拒绝的遗赠（Refused Bequest）**


**24. 注释（Comments）**

## 4. 构筑测试体系

**1. 自测试代码的价值**

一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需的时间。

**2. 自动化测试**

确保所有测试都完全自动化，让它们检查自己的测试结果。

**3. 频繁运行测试**

频繁地运行测试。对于你正在处理的代码，与其对应的测试至少每隔几分钟就要运行一次，每天至少运行一次所有的测试。

**4. 不用完美测试**

编写未臻完善的测试并经常运行，好过对完美测试的无尽等待。

**5. 探测边界条件**

考虑可能出错的边界条件，把测试火力集中在那儿。

**6. 脏数据传递**

如果这个错误会导致脏数据在应用中到处传递，或是产生一些很难调试的失败，我可能会用引入断言手法，使代码不满足预设条件时快速失败。我不会为这样的失败断言添加测试，它们本身就是一种测试的形式。

**7. 编写测试的心态**

不要因为测试无法捕捉所有的bug就不写测试，因为测试的确可以捕捉到大多数bug。

**8. Bug报告**

每当你收到bug报告，请先写一个单元测试来暴露这个bug。
