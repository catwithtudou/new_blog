
# 2403 《重构：改善既有代码的设计》阅读上

## 1. 重构，第一个示例

### 1.1 重点语句

**1. 程序添加特性前的考虑**

如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性。

**2.需求的变化使重构变得必要**

若代码能正常工作且不会再被修改（没有妨碍到任何人），则不用重构，但如果有人需要理解它的工作原理且觉得理解起来很费劲，则就需要改进代码了（妨碍他人了）。

**3. 重构前的第一步**

重构前，先检查自己是否有一套可靠的测试集。这些测试必须有自我检验能力。

**4. 重构技术的特点之一**

重构技术就是以微小的步伐（比如一开始的变量命名）修改程序。如果你犯下错误，很容易便可发现它。

**5. 优秀的程序员**

傻瓜都能写出计算机可以理解的代码。唯有能写出人类容易理解的代码的，才是优秀的程序员。

**6. 营地法则**

编程时，需要遵循营地法则:保证你离开时的代码库一定比来时更健康。

**7. 好代码的检验标准之一**

好代码的检验标准就是人们是否能轻而易举地修改它。


### 1.2 重构示例

**1. 重构示例使用到的重构手法**

- 提炼函数
- 内联变量
- 搬移函数
- 以多态取代条件表达式等

**2. 重构示例的关键节点**

- 第一步：将原函数「分解成一组嵌套的函数」
- 第二步：应用「拆分阶段」分离计算逻辑与输出格式化逻辑
- 第三步：为计算器「引入多态性」来处理计算逻辑


## 2. 重构的原则

### 2.1 何谓重构

**1. 重构的定义**

- 作为名词

对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

- 作为动词

使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。


**2. 简单识别重构的方法**

如果有人说他们的代码在重构过程中有一两天时间不可用，基本上可以确定，他们在做的事不是重构。

### 2.2 两顶帽子

**1. 两顶帽子**

- 帽子一：添加新功能

添加新功能时，不应该修改既有代码，只管添加新功能。通过添加测试并让测试正常运行，可以衡量工作进度。

- 帽子二：重构

重构时就不能再添加功能，只管调整代码的结构。此时不应该添加任何测试（除非发现有先前遗漏的东西），只在绝对必要（用以处理接口变化）时才修改测试。

**2. 无论何时得清楚戴的是哪一顶帽子，并明白不同的帽子对编程状态提出的不同要求**

### 2.3 为何重构

1. 重构改进软件的设计
2. 重构使软件更容易理解
3. 重构帮助找到 Bug
4. 重构提高编程速度

![](https://img.zhengyua.cn/blog/202403201227375.png)

### 2.4 何时重构

**1. 三次法则**

- 第一次做某件事时只管去做
- 第二次做类似的事会产生反感，但无论如何还是可以去做
- 第三次再做类似的事，你就应该重构

> 正如老话说的:事不过三，三则重构。

**2. 预备性重构：让添加新功能更加容易**

**3. 帮助理解的重构：使代码更易懂**

**4. 捡垃圾式重构**

**5. 有计划的重构和见机行事的重构**

肮脏的代码必须重构，但漂亮的代码也需要很多重构。

每次要修改时，首先令修改很容易（警告:这件事有时会很难），然后再进行这次容易的修改。

**6. 长期重构**

尽量让整个团队达成共识，来逐步解决重构的问题，而不建议一支团队专门做重构。

**7. 复审代码时重构**

**8. 怎么对经理说**

给团队一个较有争议的建议:不要告诉经理!

- 对于快速创造软件，重构可带来大帮助。如果需要添加新功能，而原本设计却又使我无法方便地修改，我发现先重构再添加新功能会更快些
- 如果要修补错误，就得先理解软件的工作方式，而我发现重构是理解软件的最快方式
- 受进度驱动的经理要我尽可能快速完成任务，至于怎么完成，那就是我的事了

**9. 何时不应该重构**

主要建议如下：

- 如果看见一块凌乱的代码，但并不需要修改它，那么就不需要重构它
- 如果重写比重构还容易，就别重构了

### 2.5 重构的挑战

**1. 延缓新功能的开发**

- 重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值
- 重构应该总是由经济利益驱动，重构的意义不在于把代码库打磨得闪闪发光，而是纯粹经济角度出发的考量，即之所以重构是因为它能让我们更快，添加功能和修复bug更快

**2. 代码所有权**

- 很多重构手法不仅会影响一个模块内部，还会影响该模块与系统其他部分的关系
- 可把旧的接口标记为“不推荐使用”(deprecated)，等一段时间之后最终让其退休；但有些时候，旧的接口必须一直保留下去
- 推荐团队代码所有制，这样一支团队里的成员都可以修改这个团队拥有的代码，即便最初写代码的是别人。这种较为宽容的代码所有制甚至可以应用于跨团队的场合

**3. 分支**

- 特性分支有其缺点，即在隔离的分支上工作得越久，将完成的工作集成(integrate)回主线就会越困难。为了减轻集成的痛苦，大多数人的办法是频繁地从主线合并(merge)或者变基(rebase)到分支
- 所以很多人认为，应该尽量缩短特性分支的生存周期，比如只有一两天。还有部分人认为应该更短，其采用的方法叫作持续集成(Continuous Integration，CI)，也叫“基于主干开发”(Trunk-Based Development)
- 并不是在说绝不应该使用特性分支，而是如果特性分支存在的时间足够短，它们就不会造成大问题(实际上，使用CI的团队往往同时也使用分支，但他们会每天将分支与主线合并)

**4. 测试**

- 不会改变程序可观察的行为，这是重构的一个重要特征
- 关键就在于“快速发现错误”，要做到这一点，其代码应该有一套完备的测试套件，并且运行速度要快，否则我会不愿意频繁运行它
- 如果没有自测试的代码，“重构风险太大，可能引入bug”的担忧是完全合理的，这也是为什么如此重视可靠的测试
- 缺乏测试的现状还催生了另一种重构的流派「只使用一组经过验证是安全的重构手法」。其要求严格遵循重构的每个步骤，并且可用的重构手法是特定于语言的。使用这种方法，团队得以在测试覆盖率很低的大型代码库上开展一些有用的重构

**5. 遗留代码**

- 重构可以很好地帮助理解遗留系统
- 需要运用重构手法创造出接缝，这样的重构很危险，因为没有测试覆盖，但这是为了取得进展必要的风险，而在这种情况下，安全的自动化重构简直就是天赐福音
- 就算有了测试，也不建议你尝试一鼓作气把复杂而混乱的遗留代码重构成漂亮的代码，而是更愿意随时重构相关的代码「每次触碰一块代码时，我会尝试把它变好一点点」

**6. 数据库**

- 一套渐进式数据库设计[mf-evodb]和数据库重构[Ambler & Sadalage]的办法，这项技术的精要在于「借助数据迁移脚本，将数据库结构的修改与代码相结合，使大规模的、涉及数据库的修改可以比较容易地开展」
- 与常规的重构不同，很多时候数据库重构最好是分散到多次生产发布来完成，这样即便某次修改在生产数据库上造成了问题，也比较容易回滚

### 2.6 重构、架构和YAGNI

**1. 重构对架构最大的影响**

- 在于通过重构，能得到一个设计良好的代码库，使其能够优雅地应对不断变化的需求

**2. 应对未来变化的办法之一**

- 就是在软件里植入灵活性机制
- 有了重构技术，可采取不同的策略。与其猜测未来需要哪些灵活性、需要什么机制来提供灵活性，我更愿意只根据当前的需求来构造软件，同时把软件的设计质量做得很高
- 但如果一种灵活性会增加软件复杂度，就必须先证明自己值得被引入

**3. YAGNI**

- “你不会需要它”(you arenʼt going to need it)的缩写，类似简单设计或增量式设计
- 把YAGNI视为将架构、设计与开发过程融合的一种工作方式，这种工作方式必须有重构作为基础才可靠
- 采用YAGNI并不表示完全不用预先考虑架构

### 2.7 重构与软件开发过程

- 如果一支团队想要重构，那么每个团队成员都需要掌握重构技能，能在需要时开展重构，而不会干扰其他人的工作
- 三大实践——自测试代码、持续集成、重构——彼此之间有着很强的协同效应，且有这三大核心实践打下的基础，才谈得上运用敏捷思想的其他部分

### 2.8 重构与性能

**1. 重构与性能**

- 我并不赞成为了提高设计的纯洁性而忽视性能，把希望寄托于更快的硬件身上也绝非正道
- 虽然重构可能使软件运行更慢，但它也使软件的性能优化更容易。除了对性能有严格要求的实时系统，其他任何情况下“编写快速软件”的秘密就是「先写出可调优的软件，然后调优它以求获得足够的速度」
- 哪怕你完全了解系统，也请实际度量它的性能，不要臆测。臆测会让你学到一些东西，但十有八九你是错的
- 短期看来，重构的确可能使软件变慢，但它使优化阶段的软件性能调优更容易，最终还是会得到好的效果

**2. 编写快速软件的方法**

- 最严格的是时间预算法。这通常只用于性能要求极高的实时系统，如果使用这种方法，分解你的设计时就要做好预算，给每个组件预先分配一定资源，包括时间和空间占用
- 持续关注法。这种方法要求任何程序员在任何时间做任何事时，都要设法保持系统的高性能

> 关于性能，一件很有趣的事情是：如果你对大多数程序进行分析，就会发现它把大半时间都耗费在一小半代码身上。如果你一视同仁地优化所有代码，90%的优化工作都是白费劲的，因为被你优化的代码大多很少被执行。

- 性能提升法。利用上述的90%统计数据，前期不对性能投以特别的关注，直至进入性能优化阶段


## 3. 代码的坏味道

**1. 神秘命名（Mysterious Name）**

!!! note "常用重构"

	**改变函数声明｜变量改名｜字段改名**

改名不仅仅是修改名字而已。如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题。为一个恼人的名字所付出的纠结，常常能推动我们对代码进行精简。

**2. 重复代码（Duplicated Code）**

!!! note "常用重构"

	**提炼函数｜移动语句｜函数上移**

一旦有重复代码存在，阅读这些重复的代码时你就必须加倍仔细，留意其间细微的差异。如果要修改重复代码，你必须找出所有的副本来修改。

**3. 过长函数（Long Function）**

!!! note "常用重构"

	**提炼函数｜查询取代临时变量｜引入参数对象｜保持对象完整｜以命令取代函数｜分解条件表达式｜以多态取代条件表达式｜拆分循环**

- 根据经验，活得最长、最好的程序，其中的函数都比较短
- 小函数的价值所在，间接性带来的好处——更好的阐释力、更易于分享、更多的选择——都是由小函数来支持的
- 固然，小函数也会给代码的阅读者带来一些负担，因为需要经常切换上下文，才能看明白函数在做什么。但现代的开发环境让你可以在函数的调用处与声明处之间快速跳转，或是同时看到这两处，让你根本不用来回跳转
- 让小函数易于理解的关键还是在于良好的命名。如果能给函数起个好名字，阅读代码的人就可以通过名字了解函数的作用，根本不必去看其中写了些什么
- 最终的效果是「你应该更积极地分解函数」。这里遵循这样一条原则「每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途(而非实现手法)命名」，关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离
- 如何确定该提炼哪一段代码呢?一个很好的技巧是「寻找注释」

**4. 过长参数列表（Long Parameter List）**

!!! note "常用重构"

	**查询取代参数｜保持对象完整｜引入参数对象｜移除标记参数｜函数组合成类**

过长的参数列表本身也经常令人迷惑。

**5. 全局数据（Global Data）**

!!! note "常用重构"

	**封装变量**

全局数据仍然是最刺鼻的坏味道之一。 全局数据的问题在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改。

> 全局数据印证了帕拉塞尔斯的格言:良药与毒药的区别在于剂量。

**6. 可变数据（Mutable Data）**


**7. 发散式变化（Divergent Change）**


**8. 霰弹式修改（Shotgun Surgery）**


**9. 依恋情结（Feature Envy）**


**10. 数据泥团（Data Clumps）**


**11. 基本类型偏执（Primitive Obsession）**


**12. 重复的（switch Repeated Switch）**


**13. 循环语句（Loops）**


**14. 冗赘的元素（Lazy Element）**


**15. 夸夸其谈通用性（Speculative Generality）**


**16. 临时字段（Temporary Field）**


**17. 过长的消息链（Message Chains）**


**18. 中间人（Middle Man）**


**19. 内幕交易（Insider Trading）**


**20. 过大的类（Large Class）**


**21. 异曲同工的类（Alternative Classes with Different Interfaces）**


**22. 纯数据类（Data Class）**


**23. 被拒绝的遗赠（Refused Bequest）**


**24. 注释（Comments）**

## 4. 构筑测试体系

**1. 自测试代码的价值**

一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需的时间。

**2. 自动化测试**

确保所有测试都完全自动化，让它们检查自己的测试结果。

**3. 频繁运行测试**

频繁地运行测试。对于你正在处理的代码，与其对应的测试至少每隔几分钟就要运行一次，每天至少运行一次所有的测试。

**4. 不用完美测试**

编写未臻完善的测试并经常运行，好过对完美测试的无尽等待。

**5. 探测边界条件**

考虑可能出错的边界条件，把测试火力集中在那儿。

**6. 脏数据传递**

如果这个错误会导致脏数据在应用中到处传递，或是产生一些很难调试的失败，我可能会用引入断言手法，使代码不满足预设条件时快速失败。我不会为这样的失败断言添加测试，它们本身就是一种测试的形式。

**7. 编写测试的心态**

不要因为测试无法捕捉所有的bug就不写测试，因为测试的确可以捕捉到大多数bug。

**8. Bug报告**

每当你收到bug报告，请先写一个单元测试来暴露这个bug。

## 6. 第一组重构

### 6.1 提炼函数（Extract Function）

![](https://img.zhengyua.cn/blog/202403221033551.png)


- **关于“何时应该把代码放进独立的函数”的问题**

“将意图与实现分开”:如果需要花时间浏览一段代码才能弄清它到底在干什么，那么就应该将其提炼到一个函数中，并根据它所做的事为其命名。以后再读到这段代码时，能一眼看到函数的用途，大多数时候根本不需要关心函数如何达成其用途(这是函数体内干的事)。

- **写非常小的函数**

通常只有几行的长度。在作者看来，一个函数一旦超过6行，就开始散发臭味。

- **大量短函数导致的性能问题**

短函数常常能让编译器的优化功能运转更良好，因为短函数可以更容易地 缓存。所以应该始终遵循性能优化的一般指导方针，不用过早担心性能问题。

- **小函数的命名**

小函数的命名需要有一个好名字。

有一个技巧是把带有注释的这段代码提炼到自己的函数中时，这里的注释往往会提示一个好名字。

??? note "具体重构步骤"

	1. 创造一个新函数，根据这个函数的意图来对它命名(以它“做什么”来命名，而 不是以它“怎样做”命名)。
	
	> 如果想要提炼的代码非常简单，例如只是一个函数调用，只要新函数的名称能够以更好的方式昭示代码意图，我还是会提炼它；但如果想不出一个更有意义的名称，这就是一个信号，可能我不应该提炼这块代码。不过不一定非得马上想出最好的名字，有时在提炼的过程中好的名字才会出现。有时我会提炼一个函数，尝试使用它，然后发现不太合适，再把它内联回去，这完全没问题。只要在这个过程中学到了东西，时间就没有白费。如果编程语言支持嵌套函数，就把新函数嵌套在源函数里，这能减少后面需要处理的超出作用域的变量个数。可稍后再使用搬移函数把它从源函数中搬移出去。

	2. 将待提炼的代码从源函数复制到新建的目标函数中

	3. 仔细检查提炼出的代码，看看其中是否引用了作用域限于源函数、在提炼出的新函数中访问不到的变量。若是，以参数的形式将它们传递给新函数

	> 如果提炼出的新函数嵌套在源函数内部，就不存在变量作用域的问题了。
	>	
	> 这些“作用域限于源函数”的变量通常是局部变量或者源函数的参数。最通用的做法是将它们都作为参数传递给新函数。只要没在提炼部分对这些变量赋值，处理起来就没什么难度。
	>	
	> 如果某个变量是在提炼部分之外声明但只在提炼部分被使用，就把变量声明也搬移到提炼部分代码中去。
	>	
	> 如果变量按值传递给提炼部分又在提炼部分被赋值，就必须多加小心。如果只有一个这样的变量，我会尝试将提炼出的新函数变成一个查询 (query)，用其返回值给该变量赋值。
	>	
	> 但有时在提炼部分被赋值的局部变量太多，这时最好是先放弃提炼。这种情况下，我会考虑先使用别的重构手法，例如拆分变量或者以查询取 代临时变量，来简化变量的使用情况，然后再考虑提炼函数。

	4. 所有变量都处理完之后，编译

	> 如果编程语言支持编译期检查的话，在处理完所有变量之后做一次编译是很有用的，编译器经常会帮你找到没有被恰当处理的变量。

	5. 在源函数中，将被提炼代码段替换为对目标函数的调用
	
	6. 测试

	7. 查看其他代码是否有与被提炼的代码段相同或相似之处。如果有，考虑使用以函数调用取代内联代码令其调用提炼出的新函数
	
	> 有些重构工具直接支持这一步。如果工具不支持，可以快速搜索一下，看看别处是否还有重复代码。

### 6.2 内联函数（Inline Function）

![](https://img.zhengyua.cn/blog/202403222323161.png)

- **非必要的间接性**

间接性可能带来帮助，但非必要的间接性总是让人不舒服。

- **先内联再提炼**

有一群组织不甚合理的函数。可以将它们都内联到一个大型函数中，再以喜欢的方式重新提炼出小函数。

- **简单委托的间接层**

如果代码中有太多间接层，使得系统中的所有函数都似乎只是对另一个函数的简单委托，造成在这些委托动作之间晕头转向，那么通常都会使用内联函数。

- **无用的间接层**

间接层有其价值，但不是所有间接层都有价值。通过内联手法，可以找出那些有用的间接层，同时将无用的间接层去除。

??? note "具体重构步骤"
	
	1. 检查函数，确定它不具多态性

	2. 找出这个函数的所有调用点

	3. 将这个函数的所有调用点都替换为函数本体

	4. 每次替换之后，执行测试

	> 不必一次完成整个内联操作。如果某些调用点比较难以内联，可以等到时机成熟后再来处理。

	5. 删除该函数的定义



### 6.3 提炼变量（Extract Variable）

![](https://img.zhengyua.cn/blog/202403222330007.png)

- **局部变量**
  
表达式有可能非常复杂而难以阅读。这种情况下，局部变量可帮助将表达式分解为比较容易管理的形式。

在面对一块复杂逻辑时，局部变量使能给其中的一部分命名，这样能更好地理解这部分逻辑是要干什么。

- **表达式命名**

一旦考虑使用提炼变量，则需要对表达式命名，而这样需要考虑这个名字所处的上下文。

如果这个名字只在当前的函数中有意义，那么提炼变量是不错的选择，但如果这个变量名在更宽的上下文中也有意义，可考虑将其暴露出来，通常以函数的形式。

- **将新名字暴露得更宽**

如果工作量很大，可先不考虑将新名字暴露，可后续使用以查询取代临时变量来处理它。

??? note "具体重构步骤"

	1. 确认要提炼的表达式没有副作用

	2. 声明一个不可修改的变量，把你想要提炼的表达式复制一份，以该表达式的结果值给这个变量赋值

	3. 用这个新变量取代原来的表达式

	4. 测试


### 6.4 内联变量（Inline Variable）

![](https://img.zhengyua.cn/blog/202403222336567.png)


- **妨碍重构的命名**

若变量名并不比表达式本身更具表现力，或会妨碍重构附近的代码，则应该通过内联的手法消除变量。

??? note "具体重构步骤"

	1. 检查确认变量赋值语句的右侧表达式没有副作用

	2. 如果变量没有被声明为不可修改，先将其变为不可修改，并执行测试

	> 这是为了确保该变量只被赋值一次。

	3. 找到第一处使用该变量的地方，将其替换为直接使用赋值语句的右侧表达式

	4. 测试

	5. 重复前面两步，逐一替换其他所有使用该变量的地方

    6. 删除该变量的声明点和赋值语句

	7. 测试


### 6.5 改变函数声明（Change Function Declaration）

### 6.6 封装变量（Encapsulate Variable）

### 6.7 变量改名（Rename Variable）

### 6.8 引入参数对象（Introduce Parameter Object）

### 6.9 函数组合成类（Combine Functions into Class）

### 6.10 函数组合成变换（Combine Functions into Transform）

### 6.11 拆分阶段（Split Phase）