
# 2403 《重构：改善既有代码的设计》阅读

## 1. 重构，第一个示例

### 1.1 重点语句

**1. 程序添加特性前的考虑**

如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性。

**2.需求的变化使重构变得必要**

若代码能正常工作且不会再被修改（没有妨碍到任何人），则不用重构，但如果有人需要理解它的工作原理且觉得理解起来很费劲，则就需要改进代码了（妨碍他人了）。

**3. 重构前的第一步**

重构前，先检查自己是否有一套可靠的测试集。这些测试必须有自我检验能力。

**4. 重构技术的特点之一**

重构技术就是以微小的步伐（比如一开始的变量命名）修改程序。如果你犯下错误，很容易便可发现它。

**5. 优秀的程序员**

傻瓜都能写出计算机可以理解的代码。唯有能写出人类容易理解的代码的，才是优秀的程序员。

**6. 营地法则**

编程时，需要遵循营地法则:保证你离开时的代码库一定比来时更健康。

**7. 好代码的检验标准之一**

好代码的检验标准就是人们是否能轻而易举地修改它。


### 1.2 重构示例

**1. 重构示例使用到的重构手法**

- 提炼函数
- 内联变量
- 搬移函数
- 以多态取代条件表达式等

**2. 重构示例的关键节点**

- 第一步：将原函数「分解成一组嵌套的函数」
- 第二步：应用「拆分阶段」分离计算逻辑与输出格式化逻辑
- 第三步：为计算器「引入多态性」来处理计算逻辑


## 2. 重构的原则

### 2.1 何谓重构

**1. 重构的定义**

- 作为名词

对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

- 作为动词

使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。


**2. 简单识别重构的方法**

如果有人说他们的代码在重构过程中有一两天时间不可用，基本上可以确定，他们在做的事不是重构。

### 2.2 两顶帽子

**1. 两顶帽子**

- 帽子一：添加新功能

添加新功能时，不应该修改既有代码，只管添加新功能。通过添加测试并让测试正常运行，可以衡量工作进度。

- 帽子二：重构

重构时就不能再添加功能，只管调整代码的结构。此时不应该添加任何测试（除非发现有先前遗漏的东西），只在绝对必要（用以处理接口变化）时才修改测试。

**2. 无论何时得清楚戴的是哪一顶帽子，并明白不同的帽子对编程状态提出的不同要求**

### 2.3 为何重构

1. 重构改进软件的设计
2. 重构使软件更容易理解
3. 重构帮助找到 Bug
4. 重构提高编程速度

![](https://img.zhengyua.cn/blog/202403201227375.png)

### 2.4 何时重构

**1. 三次法则**

- 第一次做某件事时只管去做
- 第二次做类似的事会产生反感，但无论如何还是可以去做
- 第三次再做类似的事，你就应该重构

> 正如老话说的:事不过三，三则重构。

**2. 预备性重构：让添加新功能更加容易**

**3. 帮助理解的重构：使代码更易懂**

**4. 捡垃圾式重构**

**5. 有计划的重构和见机行事的重构**

肮脏的代码必须重构，但漂亮的代码也需要很多重构。

每次要修改时，首先令修改很容易（警告:这件事有时会很难），然后再进行这次容易的修改。

**6. 长期重构**

尽量让整个团队达成共识，来逐步解决重构的问题，而不建议一支团队专门做重构。

**7. 复审代码时重构**

**8. 怎么对经理说**

给团队一个较有争议的建议:不要告诉经理!

- 对于快速创造软件，重构可带来大帮助。如果需要添加新功能，而原本设计却又使我无法方便地修改，我发现先重构再添加新功能会更快些
- 如果要修补错误，就得先理解软件的工作方式，而我发现重构是理解软件的最快方式
- 受进度驱动的经理要我尽可能快速完成任务，至于怎么完成，那就是我的事了

**9. 何时不应该重构**

主要建议如下：

- 如果看见一块凌乱的代码，但并不需要修改它，那么就不需要重构它
- 如果重写比重构还容易，就别重构了


## 3. 代码的坏味道

1. 神秘命名（Mysterious Name）
2. 重复代码（Duplicated Code）
3. 过长函数（Long Function）
4. 过长参数列表（Long Parameter List）
5. 全局数据（Global Data）
6. 可变数据（Mutable Data）
7. 发散式变化（Divergent Change）
8. 霰弹式修改（Shotgun Surgery）
9. 依恋情结（Feature Envy）
10. 数据泥团（Data Clumps）
11. 基本类型偏执（Primitive Obsession）
12. 重复的（switch Repeated Switch）
13. 循环语句（Loops）
14. 冗赘的元素（Lazy Element）
15. 夸夸其谈通用性（Speculative Generality）
16. 临时字段（Temporary Field）
17. 过长的消息链（Message Chains）
18. 中间人（Middle Man）
19. 内幕交易（Insider Trading）
20. 过大的类（Large Class）
21. 异曲同工的类（Alternative Classes with Different Interfaces）
22. 纯数据类（Data Class）
23. 被拒绝的遗赠（Refused Bequest）
24. 注释（Comments）
