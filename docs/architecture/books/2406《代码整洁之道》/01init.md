# 01-06

## 1. 整洁代码

- 记住，代码确然是我们最终用来表达需求的那种语言。我们可以创造各种与需求接近的语言。我们可以创造帮助把需求解析和汇整为正式结构的各种工具。然而，**我们永远无法抛弃必要的精确性——所以代码永存**
- 我们都曾经瞟一眼自己亲手造成的混乱，决定弃之而不顾，走向新一天。我们都曾经看到自己的烂程序居然能运行，然后断言能运行的烂程序总比什么都没有强。我们都曾经说过有朝一日再回头清理。当然，在那些日子里，我们都没听过勒布朗（LeBlanc）法则：**稍后等于永不（Later equals never）**
- 随着混乱的增加，团队生产力也持续下降，趋向于零。当生产力下降时，管理层就只有一件事可做了：增加更多人手到项目中，期望提升生产力。可是新人并不熟悉系统的设计。他们搞不清楚什么样的修改符合设计意图，什么样的修改违背设计意图。而且，他们以及团队中的其他人都背负着提升生产力的可怕压力。于是，**他们制造更多的混乱，驱动生产力向零那端不断下降**
  
  ![生产力](https://img.zhengyua.cn/blog/202406221833948.png)

- 花时间保持代码整洁不但有关效率，**还有关生存**
- **我们与项目的规划脱不了干系，对失败负有极大的责任**；特别是当失败与糟糕的代码有关时尤为如此！
- 多数经理想要知道实情，即便他们看起来不喜欢实情。多数经理想要好代码，即便他们总是痴缠于进度。他们会奋力卫护进度和需求；那是他们该干的。**你则当以同等的热情卫护代码。程序员遵从不了解混乱风险的经理的意愿，也是不专业的做法**
- 混乱只会立刻拖慢你，叫你错过期限。赶上期限的唯一方法——做得快的唯一方法——就是**始终尽可能保持代码整洁**
- 写整洁代码，需要遵循大量的小技巧，**贯彻刻苦习得的“整洁感”。这种“代码感”就是关键所在。**有些人生而有之。有些人费点劲才能得到。它不仅让我们看到代码的优劣，还予我们以借戒规之力化劣为优的攻略

??? note "什么是整洁的代码" 

    Bjarne Stroustrup:

    “我喜欢优雅和高效的代码。代码逻辑应当直截了当，叫缺陷难以隐藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码；性能调至最优，省得引诱别人做没规矩的优化，搞出一堆混乱来。整洁的代码只做好一件事。”

    Grady Booch:

    “整洁的代码简单直接。整洁的代码如同优美的散文。整洁的代码从不隐藏设计者的意图，充满了干净利落的抽象和直截了当的控制语句。”

    Dave Thomas:

    “整洁的代码应可由作者之外的开发者阅读和增补。它应当有单元测试和验收测试。它使用有意义的命名。它只提供一种而非多种做一件事的途径。它只有尽量少的依赖关系，而且要明确地定义和提供清晰、尽量少的API。代码应通过其字面表达含义，因为不同的语言导致并非所有必需信息均可通过代码自身清晰表达。”

    Michael Feathers:

    “我可以列出我留意到的整洁代码的所有特点，但其中有一条是根本性的。整洁的代码总是看起来像是某位特别在意它的人写的。几乎没有改进的余地。代码作者什么都想到了，如果你企图改进它，总会回到原点，赞叹某人留给你的代码——全心投入的某人留下的代码。”
    
    Ron Jeffries:

    “近年来，我开始研究贝克的简单代码规则，差不多也都琢磨透了。简单代码，依其重要顺序：
  
     - 能通过所有测试；
     - 没有重复代码；
     - 体现系统中的全部设计理念；
     - 包括尽量少的实体，比如类、方法、函数等。
    
    在以上诸项中，我最在意代码重复。如果同一段代码反复出现，就表示某种想法未在代码中得到良好的体现。我尽力去找出到底那是什么，然后再尽力更清晰地表达出来。

    在我看来，有意义的命名是体现表达力的一种方式，我往往会修改好几次才会定下名字来。借助Eclipse这样的现代编码工具，重命名代价极低，所以我无所顾忌。然而，表达力还不只体现在命名上。我也会检查对象或方法是否想做的事太多。如果对象功能太多，最好是切分为两个或多个对象。如果方法功能太多，我总是使用抽取手段（Extract Method）重构之，从而得到一个能较为清晰地说明自身功能的方法，以及另外数个说明如何实现这些功能的方法。

    消除重复和提高表达力让我在整洁代码方面获益良多，只要铭记这两点，改进脏代码时就会大有不同。不过，我时常关注的另一规则就不太好解释了。

    这么多年下来，我发现所有程序都由极为相似的元素构成。例如“在集合中查找某物”。不管是雇员记录数据库还是名-值对哈希表，或者某类条目的数组，我们都会发现自己想要从集合中找到某一特定条目。一旦出现这种情况，我通常会把实现手段封装到更抽象的方法或类中。这样做好处多多。

    可以先用某种简单的手段，比如哈希表来实现这一功能，由于对搜索功能的引用指向了我那个小小的抽象，就能随需应变，修改实现手段。这样就既能快速前进，又能为未来的修改预留余地。

    另外，该集合抽象常常提醒我留意“真正”在发生的事，避免随意实现集合行为，因为我真正需要的不过是某种简单的查找手段。

    减少重复代码，提高表达力，提早构建简单抽象。这就是我写整洁代码的方法。”

    Ward Cunningham:

    “如果每个例程都让你感到深合己意，那就是整洁代码。如果代码让编程语言看起来像是专为解决那个问题而存在，就可以称之为漂亮的代码。”

- 你该明白了。读与写花费时间的比例超过10:1。**写新代码时，我们一直在读旧代码。**编写代码的难度，取决于读周边代码的难度。要想干得快，要想早点做完，**要想轻松写代码，先让代码易读吧**
- 光把代码写好可不够。**必须时时保持代码整洁。**我们都见过代码随时间流逝而腐坏。我们应当更积极地阻止腐坏的发生。

??? 小结

    艺术书并不保证你读过之后能成为艺术家，只能告诉你其他艺术家用过的工具、技术和思维过程。本书同样也不担保让你成为好程序员。它不担保能给你代码感”。它所能做的，只是展示好程序员的思维过程，还有他们使用的技巧、技术和工具。

    和艺术书一样，本书也充满了细节。代码会很多。你会看到好代码，也会看到糟糕的代码。你会看到糟糕的代码如何转化为好代码。你会看到启发、规条和技巧的列表。你会看到一个又一个例子。但最终结果取决于你自己。

    还记得那个关于小提琴家在去表演的路上迷路的老笑话吗？他在街角拦住一位长者，问他怎么才能去卡耐基音乐厅（Carnegie Hall）。长者看了看小提琴家，又看了看他手中的琴，说道：“你还得练，孩子，还得练！

## 2. 有意义的命名

!!! quote 

    **“既然有这么多命名要做，不妨做好它。”**

**1. 名副其实**

- **选个好名字要花时间，但省下来的时间比花掉的多。**注意命名，而且一旦发现有更好的名称，就换掉旧的。这么做，读你代码的人（包括你自己）都会更开心。
- 如果名称需要注释来补充，那就不算是名副其实。
- 选择体现本意的名称能让人更容易理解和修改代码。
- 问题不在于代码的简洁度，而是在于代码的模糊度：**即上下文在代码中未被明确体现的程度。**

**2. 避免误导**

- 程序员必须避免留下掩藏代码本意的错误线索。**应当避免使用与本意相悖的词。**
- 提防使用不同之处较小的名称。
- 以同样的方式拼写出同样的概念才是信息。**拼写前后不一致就是误导。**

**3. 做有意义的区分**

- 如果程序员只是为满足编译器或解释器的需要而写代码，**就会制造麻烦。**
- 废话是另一种没意义的区分。
- 注意，只要体现出有意义的区分，使用 a 和 the 这样的前缀就没错。
- 废话都是冗余。
- 要区分名称，就要以读者能鉴别不同之处的方式来区分。

**4. 使用读得出来的名称**

- 这不是小事，因为**编程本就是一种社会活动。**

**5. 使用可搜索的名称**

- 长名称胜于短名称，搜得到的名称胜于用自造编码代写就的名称。
- 若变量或常量可能在代码中多处使用，则应赋其以便于搜索的名称。

**6. 避免使用编码**

- 把类型或作用域编进名称里面，**徒然增加了解码的负担。**
- 如今HN和其他类型编码形式都纯属多余。
- 也不必用 m_前缀来标明成员变量。应当把类和函数做得足够小，消除对成员前缀的需要。
- 前缀变作了不入法眼的废料，变作了旧代码的标志物。
- 如果接口和实现必须选一个来编码的话，我宁肯选择实现。ShapeFactoryImp，甚至是丑陋的CShapeFactory，**都比对接口名称编码来得好。**

**7. 避免思维映射**

- 不应当让读者在脑中把你的名称翻译为他们熟知的名称。这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。
- 程序员通常都是聪明人。聪明人有时会借脑筋急转弯炫耀其聪明。
- 聪明程序员和专业程序员之间的区别在于，**专业程序员了解，明确是王道。**专业程序员善用其能，编写其他人能理解的代码。

**8. 类名&方法名**

- 类名和对象名应该是名词或名词短语。
- 方法名应当是动词或动词短语。
- 重载构造器时，使用描述了参数的静态工厂方法名。

**9. 别抖机灵**

- 如果名称太耍宝，那就只有同作者一般有幽默感的人才能记得住，而且还是在他们记得那个笑话的时候才行。
- 言到意到。意到言到。

**10. 每个概念对应一个词**

- 给每个抽象概念选一个词，**并且一以贯之。**
- 函数名称应当独一无二，而且要保持一致，这样你才能不借助多余的浏览就找到正确的方法。

**11. 别用双关语**

- 避免将**同一单词用于不同目的。**
- 代码作者应尽力写出易于理解的代码。我们想把代码写得让别人能一目尽览，而不必殚精竭虑地研究。我们想要那种大众化的作者尽责写清楚的平装书模式；我们不想要那种学者挖地三尺才能明白个中意义的学院派模式。

**12. 使用解决方案领域名称**

- 记住，**只有程序员才会读你的代码。**
- 程序员要做太多技术性工作。给这些事取个技术性的名称，通常是最靠谱的做法。

**13. 使用源自所涉问题领域的名称**

- 如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉问题领域而来的名称吧。
- **与所涉问题领域更为贴近的代码**，应当采用源自问题领域的名称。

**14. 添加有意义的语境&不要添加没用的语境**

- 很少有名称是能自我说明的——多数都不能。反之，你需要用有良好命名的类、函数或名称空间来放置名称，**给读者提供语境**。如果没这么做，给名称添加前缀就是最后一招了。
- 语境的增强也让算法能够通过分解为更小的函数而变得更为干净利落。
- 只要短名称足够清楚，就要比长名称好。**别给名称添加不必要的语境。**
- 精确正是命名的要点。

??? 最后的话

    取好名字最难的地方在于需要良好的描述技巧和共有文化背景。与其说这是一种技术、商业或管理问题，还不如说是一种教学问题。其结果是，这个领域内的许多人都没能学会做得很好。

## 3. 函数

> 函数是所有程序中的第一组代码。

### 3.1 短小

- **函数的第一规则是要短小。第二条规则是还要更短小。** 经过漫长的试错，经验告诉我们，函数就该小。
- 每个函数都一目了然。每个函数都只说一件事。而且每个函数都依序把你带到下一个函数，这就是函数应该达到的短小程度。
- if语句、else语句、while语句等，其中的代码块应该只有一行。 **该行大抵应该是一个函数调用语句。** 这样不但能保持函数短小，而且因为块内调用的函数拥有较具说明性的名称，从而增加了文档上的价值。

### 3.2 只做一件事

- **函数应该做一件事。做好这件事。只做这一件事。**
- **如果函数只是做了该函数名下同一抽象层上的步骤，则函数还是只做了一件事。** 编写函数毕竟是为了把大一些的概念（换言之，函数的名称）拆分为另一抽象层上的一系列步骤。
- 所以，要判断函数是否不止做了一件事还有一个方法，**就是看是否能再拆出一个函数，** 该函数不仅只是单纯地重新诠释其实现。
- **只做一件事的函数无法被合理地切分为多个区段。** 这就是函数做事太多的明显征兆。

### 3.3 每个函数一个抽象层级

- 要确保函数只做一件事，**函数中的语句都要在同一抽象层级上。**
- **函数中混杂不同抽象层级，往往让人迷惑。** 读者可能无法判断某个表达式是基础概念还是细节。更恶劣的是，一旦细节与基础概念混杂，更多的细节就会在函数中纠结起来。
- 我们想要让**代码拥有自顶向下的阅读顺序**。我们想要让每个函数后面都跟着位于下一抽象层级的函数，这样一来，在查看函数列表时，就能偱抽象层级向下阅读了。即叫做做向下规则。
- 让代码读起来像是**一系列自顶向下的To起头段落是**保持抽象层级协调一致的有效技巧。

### 3.4 switch语句

- 写出短小的switch语句很难。即便是只有两种条件的switch语句也要比想要的单个代码块或函数大得多。写出只做一件事的switch语句也很难。Switch天生要做N件事。不幸我们总无法避开switch语句，不过**还是能够确保每个switch都埋藏在较低的抽象层级，而且永远不重复**。当然可利用多态来实现这一点。
- 对于switch语句，我的规矩是如果**只出现一次，用于创建多态对象，而且隐藏在某个继承关系中，在系统其他部分看不到**，就还能容忍。

### 3.5 使用描述性的名称

- 记住沃德原则：**“如果每个例程都让你感到深合己意，那就是整洁代码。”** 要遵循这一原则，泰半工作都在于为只做一件事的小函数取个好名字。函数越短小、功能越集中，就越便于取个好名字。
- **别害怕长名称。长而具有描述性的名称，要比短而令人费解的名称好。** 长而具有描述性的名称，要比描述性的长注释好。使用某种命名约定，让函数名称中的多个单词容易阅读，然后使用这些单词给函数取个能说清其功用的名称。
- 别害怕花时间取名字。你当尝试不同的名称，实测其阅读效果。
- 选择描述性的名称能理清你关于模块的设计思路，并帮你改进之。**追索好名称，往往导致对代码的改善重构。**
- **命名方式要保持一致。** 使用与模块名一脉相承的短语、名词和动词给函数命名。

### 3.6 函数参数

- **最理想的参数数量是零（零参数函数）**，其次是1（单参数函数)，再次是2（双参数函数），应尽量避免3（三参数函数）。有足够特殊的理由才能用3个以上参数（多参数函数）——所以无论如何也不要这么做。
- **参数不易对付。它们带有太多概念性。** 参数与函数名处在不同的抽象层级，它要求你了解目前并不特别重要的细节。
- 从测试的角度看，参数甚至更叫人为难。
- 输出参数比输入参数还要难以理解。
- 相较于没有参数，只有一个输入参数算是第二好的做法。

**1. 单参数函数的普遍形式**

- 你应当选用较能区别这两种理由的名称，而且**总在一致的上下文中使用这两种形式。**
- 还有虽不那么普遍但仍极有用的单参数函数形式，那就是事件（event）。在这种形式中，有输入参数而无输出参数。小心使用这种形式。应该让读者很清楚地了解它是个事件。谨慎地选用名称和上下文语境。
- 尽量避免编写不遵循这些形式的一元函数。

**2. 标识参数**

- **标识参数丑陋不堪。** 向函数传入布尔值简直就是骇人听闻的做法。这样做，方法签名立刻变得复杂起来，大声宣布本函数不止做一件事。

**3. 双参数函数**

- **有两个参数的函数要比一元函数难懂。** 尽管两种情况下意义都很清楚，但第一个只要扫一眼就明白，更好地表达了其意义。第二个就得暂停一下才能明白，除非我们学会忽略第一个参数。而且最终那也会导致问题，因为我们根本就不该忽略任何代码。忽略掉的部分就是缺陷藏身之地。当然，有些时候两个参数正好。
- 二元函数不算恶劣，而且你当然也会编写二元函数。**不过你得小心使用二元函数要付出代价。** 你应该尽量利用一些机制将其转换成一元函数。

**4. 三参数函数**

- **有三个参数的函数要比二元函数难懂得多。** 排序、琢磨、忽略的问题都会加倍体现。建议你在写三元函数前一定要想清楚。

**5. 参数对象**

- 如果函数看来需要两个、三个或三个以上参数，就说明其中**一些参数应该封装为类了。**
- 从参数创建对象，从而减少参数数量，看起来像是在作弊，但实则并非如此。

**6. 参数列表**

- 有时我们想要向函数传入数量可变的参数。如果可变参数像上例中那样被同等对待，就和类型为List的单个参数没什么两样。
- 有可变参数的函数可能是一元、二元甚至三元。**超过这个数量就可能要犯错了。**

**7. 动词与关键词**

- **给函数取个好名字，能较好地解释函数的意图，以及参数的顺序和意图。** 对于一元函数，函数和参数应当形成一种非常良好的动词/名词对形式。
- 最后那个例子展示了**函数名称的关键字（keyword）形式。** 使用这种形式，我们把参数的名称编码成了函数名。


### 3.7 无副作用

- **副作用是一种谎言。函数承诺只做一件事，但还是会做其他被藏起来的事。** 有时它会对自己类中的变量做出未能预期的改动。有时，它会把变量搞成向函数传递的参数或是系统全局变量。**无论哪种情况，都是具有破坏性的，会导致古怪的时序性耦合及顺序依赖。**
- 这一副作用造出了一次时序性耦合。如果一定要时序性耦合，就应该在函数名称中说明。
- **参数多数会被自然而然地看作是函数的输入。** 如果你编过好些年程序，我担保你一定被用作输出而非输入的参数迷惑过。
- 事情清楚了但付出了检查函数声明的代价。你被迫检查函数签名，就得花上一点时间。**应该避免这种中断思路的事。**
- **普遍而言应避免使用输出参数。** 如果函数必须要修改某种状态，就修改所属对象的状态吧。

### 3.8 分隔指令与询问

- **函数要么做什么事，要么回答什么事，但二者不可得兼。** 函数应该修改某对象的状态，或是返回该对象的有关信息。两样都干常会导致混乱。
- 真正的解决方案是把**指令与询问分隔开来，防止混淆的发生。**

### 3.9 使用异常替代返回错误码

- 从**指令式函数返回错误码轻微违反了指令与询问分隔的规则。** 它鼓励了在if语句判断中把指令当作表达式使用。
- 这不会引起动词/形容词混淆，但却导致更深层次的嵌套结构。**当返回错误码时，就是在要求调用者立刻处理错误。**
- **如果使用异常替代返回错误码，** 错误处理代码就能从主路径代码中分离出来，得到简化。

**1. 抽离 try/catch 代码块**

- Try/catch代码块丑陋不堪。它们搞乱了代码结构，把错误处理与正常流程混为一谈。**最好把try和catch代码块的主体部分抽离出来，另外形成函数。**

**2. 错误处理就是一件事**

- 函数应该只做一件事。错误处理就是一件事。因此，**处理错误的函数不该做其他事。**

**3. Error.java 依赖磁铁**

- 这样的类就是一块依赖磁铁（dependency magnet）；其他许多类都得导入和使用它。
- **使用异常替代错误码，新异常就可以从异常类派生出来，** 无需重新编译或重新部署。

### 3.10 别重复自己

- **这样的重复还是会导致问题，因为代码因此而臃肿，** 且当算法改变时需要修改4处地方。而且也会增加4次放过错误的可能性。
- 整个模块的可读性因为**重复的消除而得到了提升。** 重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建。

### 3.11 结构化编程

- 有些程序员遵循 **Edsger Dijkstra 的结构化编程规则**。Dijkstra 认为，每个函数、函数中的每个代码块都应该有一个入口、一个出口。遵循这些规则，意味着在每个函数中只该有一个 return 语句，循环中不能有 break 或 continue 语句，而且永永远远不能有任何 goto 语句。
- 我们赞成结构化编程的目标和规范，**但对于小函数，这些规则助益不大。** 只有在大函数中，这些规则才会有明显的好处。 所以只要函数保持短小，偶尔出现的 return、break 或 continue 语句没有坏处，甚至还比单入单出原则更具有表达力。另外一方面，goto 只在大函数中才有道理，所以应该尽量避免使用。


### 3.12 如何写出这样的函数

- 写代码和写别的东西很像。在写论文或文章时，你先想什么就写什么，然后再打磨它。初稿也许粗陋无序，你就斟酌推敲，直至达到你心目中的样子。

### 3.13 小结

- 每个系统都是使用某种领域特定语言搭建，而这种语言是程序员设计来描述那个系统的。函数是语言的动词，类是名词。这并非是退回到那种认为需求文档中的名词和动词就是系统中类和函数的最初设想的可怕的旧观念。**其实这是个历史更久的真理。编程艺术是且一直就是语言设计的艺术。**
- 本章所讲述的是有关编写良好函数的机制。如果你遵循这些规则，函数就会短小，有个好名字，而且被很好地归置。不过永远别忘记，真正的目标在于讲述系统的故事，而**你编写的函数必须干净利落地拼装到一起，形成一种精确而清晰的语言，帮助你讲故事。**

## 4. 注释

## 5. 格式

## 6. 对象和数据结构
