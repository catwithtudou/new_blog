# 07-12

## 7 错误处理


> 错误处理只不过是编程时必须要做的事之一。输入可能出现异常，设备可能失效。简言之可能会出错，当错误发生时，程序员就有责任确保代码照常工作。 
> 
> 错误处理很重要，但如果它搞乱了代码逻辑，就是错误的做法。

### 7.1 使用异常而非返回码

- 在很久以前，许多语言都不支持异常。这些语言处理和汇报错误的手段都有限。你要么设置一个错误标识，要么返回给调用者检查的错误码。 
- **遇到错误时，最好抛出一个异常**。调用代码很整洁，其逻辑不会被错误处理搞乱。


### 7.2 先写 Try-Catch-Finally语句

- 异常的妙处之一是，它们在**程序中定义了一个范围**。执行try-catch-finally语句中try部分的代码时，你是在表明可随时取消执行，并在catch语句中接续。 
- 在编写可能抛出异常的代码时，最好先写出try-catch-finally语句。这能**帮你定义代码的用户应该期待什么**，无论try代码块中执行的代码出什么错都一样。
- 用try-catch结构定义了一个范围，可以继续用**测试驱动(TDD)方法构建剩余的代码逻辑**。

### 7.3 使用不可控异常

- 可控异常的代价就是**违反开放/闭合原则**。如果在方法中抛出可控异常，而catch语句在三个层级之上，就得在catch语句和抛出异常处之间的每个方法签名中声明该异常。这意味着对**软件中较低层级的修改，都将波及较高层级的签名**。修改好的模块必须重新构建和发布，即便它们自身所关注的任何东西都没改动过。 
- 最终得到的就是一个从**软件最底端贯穿到最高端的修改链**！封装被打破了，因为在抛出路径中的每个函数都要去了解下一层级的异常细节。既然异常旨在让你能在较远处处理错误，**可控异常以这种方式破坏封装简直就是一种耻辱**。 
- 如果你在编写一套关键代码库，则可控异常有时也会有用：你**必须捕获异常**。但对于一般的应用开发，**其依赖成本要高于收益**。

### 7.4 给出异常发生的环境说明

- 你抛出的每个异常，都应当提供**足够的环境说明，以便判断错误的来源和处所**。 
- **应创建信息充分的错误消息**，并和异常一起传递出去。在消息中，包括失败的操作和失败类型。

### 7.5 依调用者需要定义异常类

- 对错误分类有很多方式。不过当我们在应用程序中定义异常类时，**最重要的考虑应该是它们如何被捕获**。
- 就可以通过打包调用API、确保它返回通用异常类型，从而简化代码。
- 实际上**将第三方API打包是个良好的实践手段**。当你打包一个第三方API，就降低了对它的依赖：未来你可以不太痛苦地改用其他代码库。在你测试自己的代码时，打包也有助于模拟第三方调用。
- 对于代码的某个特定区域，**单一异常类通常可行**。伴随异常发送出来的信息能够区分不同错误。如果你想要**捕获某个异常并且放过其他异常**，就使用不同的异常类。


### 7.6 定义常规流程

- 这样做却把**错误检测推到了程序的边缘地带**。你打包了外部API以抛出自己的异常，你在代码的顶端定义了一个处理器来应付任何失败了的运算。
- 这种手法叫做**特例模式（SPECIAL CASE PATTERN）**。 创建一个类或配置一个对象，用来处理特例。你来处理特例，客户代码就不用应付异常行为了。异常行为被封装到特例对象中。

### 7.7 别返回null 值

- **返回null值，基本上是在给自己增加工作量，也是在给调用者添乱**。只要有一处没检查null值，应用程序就会失控。
- 如果你打算在方法中返回null值，**不如抛出异常，或是返回特例对象**。如果你在调用某个第三方API中可能返回null值的方法，可以考虑用**新方法打包这个方法**，在新方法中抛出异常或返回特例对象。

### 7.8 别传递null值

- 在方法中**返回null值是糟糕的做法，但将null值传递给其他方法就更糟糕了**。除非API要求你向它传递null值，否则就要尽可能避免传递null值。
- 还有替代方案。可以使用一组断言。
- 在大多数编程语言中，没有良好的方法能对付由调用者意外传入的null值。事已如此，**恰当的做法就是禁止传入null值**。这样你在编码的时候，就会时时记住参数列表中的null值意味着出问题了，从而大量避免这种无心之失。

### 7.9 小结

整洁代码是可读的，但也要强固。**可读与强固并不冲突**。如果将错误处理隔离看待，独立于主要逻辑之外，就能写出强固而整洁的代码。做到这一步，我们就能单独处理它，也极大地提升了代码的可维护性。

## 8 边界

> 不管是哪种情况，我们都得将外来代码干净利落地整合进自己的代码中。

### 8.1 使用第三方代码

- 在**接口提供者和使用者之间，存在与生俱来的矛盾**。第三方程序包和框架提供者追求普适性，这样就能在多个环境中工作，吸引广泛的用户。而使用者则想要集中满足特定需求的接口。这种矛盾会导致系统边界上出现问题。
- **边界上的接口是隐藏的**。它能随来自应用程序其他部分的极小的影响而变动。
- 该接口也经过仔细**修整和归置以适应应用程序的需要**。结果就是得到易于理解、难以被误用的代码。
- 如果你使用类似Map这样的边界接口，**就把它保留在类或近亲类中**。避免从公共API中返回边界接口，或将边界接口作为参数传递给公共API。


### 8.2 浏览和学习边界

- 第三方代码帮助我们在更少时间内发布更丰富的功能。在利用第三方程序包时，该从何处入手呢？我们没有测试第三方代码的职责，但**为要使用的第三方代码编写测试，可能最符合我们的利益**。
- 学习第三方代码很难。整合第三方代码也很难。同时做这两件事难上加难。如果我们采用不同的做法呢？**不要在生产代码中试验新东西，而是编写测试来遍览和理解第三方代码**。Jim Newkirk 把这叫做**学习性测试（learning tests）**。
- 在学习性测试中，我们如在应用中那样调用第三方代码。我们基本上是在通过**核对试验来检测自己对那个API的理解程度**。测试聚焦于我们想从API得到的东西。

### 8.3 学习性测试的好处不只是免费

- **学习性测试毫无成本**。无论如何我们都得学习要使用的API，而编写测试则是获得这些知识的容易而不会影响其他工作的途径。学习性测试是一种精确试验，帮助我们增进对API的理解。
- **学习性测试不光免费，还在投资上有正面的回报**。当第三方程序包发布了新版本，我们可以运行学习性测试，看看程序包的行为有没有改变。
- 学习性测试确保第三方程序包按照我们想要的方式工作。**一旦整合进来，就不能保证第三方代码总与我们的需要兼容**。原作者不得不修改代码来满足他们自己的新需要。他们会修正缺陷、添加新功能。风险伴随新版本而来。如果第三方程序包的修改与测试不兼容，我们也能马上发现。
- 无论你是否需要通过学习性测试来学习，总要有一系列与生产代码中调用方式一致的输出测试来支持整洁的边界。**不使用这些边界测试来减轻迁移的劳力，我们可能会超出应有时限，长久地绑在旧版本上面**。

### 8.4 使用尚不存在的代码

- 另一种边界是那种**将已知和未知分隔开的边界**。在代码中总有许多地方是我们的知识未及之处。有时边界那边就是未知的（至少目前未知）。有时，我们并不往边界那边看过去。
- 编写我们想得到的接口，好处之一是**它在我们控制之下**。这有助于保持客户代码更可读，且集中于它该完成的工作。
- ADAPTER **封装了与API的互动**，也提供了一个当API发生变动时唯一需要改动的地方。

### 8.5 整洁的边界

- 边界上会发生有趣的事。**改动是其中之一**。有良好的软件设计，无需巨大投入和重写即可进行修改。在使用我们控制不了的代码时，必须加倍小心保护投资，确保未来的修改不至于代价太大。
- 边界上的代码需要**清晰的分割和定义了期望的测试**。应该避免我们的代码过多地了解第三方代码中的特定信息。**依靠你能控制的东西，好过依靠你控制不了的东西**，免得日后受它控制。
- 我们通过代码中少数几处**引用第三方边界接口的位置来管理第三方边界**。

## 9 单元测试

> 敏捷和TDD运动鼓舞了许多程序员编写自动化单元测试，每天还有更多人加入这个行列。但是在争先恐后将测试加入规程中时，许多程序员遗漏了一些关于编写好测试的更细微但却重要的要点。

### 9.1 TDD三定律

- 定律一：在编写不能通过的单元测试前，不可编写生产代码。 
- 定律二：只可编写刚好无法通过的单元测试，不能编译也算不通过。
- 定律三：只可编写刚好足以通过当前失败测试的生产代码。


### 9.2 保持测试整洁

- 那个团队认定，测试代码的维护**不应遵循生产代码的质量标准**。
    - 他们彼此默许在单元测试中破坏规矩。这个团队没有意识到的是，**脏测试等同于——如果不是坏于的话——没测试**。问题在于测试必须随生产代码的演进而修改。测试越脏，就越难修改。测试代码越缠结，你就越有可能花更多时间塞进新测试，而不是编写新生产代码。修改生产代码后，旧测试就会开始失败，而测试代码中乱七八糟的东西将阻碍代码再次通过。于是测试变得就像是不断翻番的债务。
    - 随着版本递进团队维护测试代码组的代价也在上升。最终，它变成了开发者最大的抱怨对象。当经理们问及为何超支如此巨大，开发者们就归咎于测试。最后他们只能扔掉了整个测试代码组。
    - 但是没有了测试代码组，他们就**失去了确保对代码的改动能如愿工作的能力**。没有了测试代码组，他们就无法确保对系统某个部分的修改不会影响到系统的其他部分。故障率开始增加。随着并非出自有意的故障越来越多，他们开始害怕做改动。他们不再清理生产代码，因为他们害怕修改带来的损害多于收益。**生产代码开始腐坏**。最后他们只剩下没有测试、纷乱而缺陷缠身的生产代码，沮丧的客户，还有对测试的失望。
- 故事的寓意很简单：**测试代码和生产代码一样重要。它可不是二等公民**。它需要被思考、被设计和被照料。它该像生产代码一般保持整洁。
- 如果测试不能保持整洁，你就会失去它们。没有了测试则会**失去保证生产代码可扩展的一切要素**。你没看错。正是单元测试让你的代码可扩展、可维护、可复用。原因很简单。有了测试则不担心对代码的修改！没有测试则每次修改都可能带来缺陷。
- 覆盖了生产代码的**自动化单元测试程序组能尽可能地保持设计和架构的整洁**。测试带来了一切好处，因为测试使改动变得可能。如果测试不干净，你改动自己代码的能力就有所牵制，而你也会开始失去改进代码结构的能力。**测试越脏，代码就会变得越脏**。最终你丢失了测试，代码开始腐坏。

### 9.3 整洁的测试

- 整洁的测试有什么要素?有三个要素：可读性，可读性和可读性。在单元测试中，**可读性甚至比在生产代码中还重要**。测试如何才能做到可读？和其他代码中一样：**明确，简洁，还有足够的表达力**。在测试中你要以尽可能少的文字表达大量内容。
- 这些测试显然呈现了**构造-操作-检验（BUILD-OPERATE-CHECK）模式**。每个测试都清晰地拆分为三个环节。第一个环节构造测试数据，第二个环节操作测试数据，第三个部分检验操作是否得到期望的结果。

**1. 面向特定领域的测试语言**

- 我们没有直接使用程序员用来对系统进行操作的API，而是**打造了一套包装这些API的函数和工具代码**，这样就能更方便地编写测试，写出来的测试也更便于阅读。那正是一种测试语言，可以帮助程序员编写自己的测试，也可以帮助后来者阅读测试。
- 这种**测试API并非起初就设计出来**，而是在对那些充满令人迷惑细节的测试代码进行后续重构时逐渐演进。

**2. 双重标准**

- 在某种意义上，本章开始处提到的那个团队的做法是正确的。**测试API中的代码与生产代码相比，的确有一套不同的工程标准**。测试代码应当简单、精悍、足具表达力，但它该和生产代码一般有效。毕竟它是在测试环境而非生产环境中运行，这两种环境有着截然不同的需求。
- 这就是双重标准。**有些事你大概永远不会在生产环境中做，而在测试环境中做却完全没问题**。通常这关乎内存或CPU效率的问题，不过却永远不会与整洁有关。


### 9.4 每个测试一个断言

- 有个流派认为：JUnit 中**每个测试函数都应该有且只有一个断言语句**。这条规则看似过于苛求，但其好处却可以在代码清单中看到。这些测试都归结为一个可快速方便地理解的结论。
- 注意修改了那些函数的名称，以符合 given-when-then 约定。这让测试更易阅读。若如此分解测试则导致了许多重复代码 的出现。可利用模板方法（TEMPLATE METHOD）模式，将 given/when 部分放到基类中，将 then 部分放到派生类中，消除代码重复问题。
- 我认为，单个断言是个好准则。我通常都会创建支持这条准则的特定领域测试语言，如代码清单所示。不过我也不害怕在单个测试中放入一个以上断言。我认为**最好的说法是单个测试中的断言数量应该最小化**。
- 最佳规则也许是应该尽可能减少每个概念的断言数量，**每个测试函数只测试一个概念**。

### 9.5 F.I.R.S.T.

1. **快速(Fast)**：测试应该够快。测试应该能快速运行。测试运行缓慢，你就不会想要频繁地运行它。 
2. **独立(Independent)**：测试应该相互独立。某个测试不应为下一个测试设定条件。 
3. **可重复(Repeatable)**：测试应当可在任何环境中重复通过。你应该能够在生产环境、质检环境中运行测试。 
4. **自足验证(Self-Validating)**：测试应该有布尔值输出。无论是通过或失败，你不应该查看日志文件来确认测试是否通过。 
5. **及时(Timely)**：测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。

### 9.6 小结

- 对于项目的健康度，测试盒生产代码同等重要。或许测试更为重要，因为它保证和增强了生产代码的可扩展性、可维护性和可复用性。**所以保持测试整洁吧。让测试具有表达力并短小精悍。发明作为面向特定领域语言的测试API，帮助自己编写测试**。如果你坐视测试腐坏，那么代码也会跟着腐坏。保持测试整洁吧。

## 10  类


## 11  系统


## 12  迭进

