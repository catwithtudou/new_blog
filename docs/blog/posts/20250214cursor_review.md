---
date: 2025-02-14
categories:
  - AIGC
tags:
  - LLM
  - AIGC
---

# 探索 Cursor—AI 编程的“版本答案”之一

> **文档目标**
>
> - 科普当前 AI 编程的“版本答案”之一——Cursor 的概念及使用
> - 帮助了解 Cursor 的基本用法和高阶用法
> - 探讨 Cursor 的适用场景和短板以及最佳实践
>
> **阅读受众**
>
> - 对 AI（或 LLM）编程感兴趣，希望了解当下相关工具来帮助理解
> - 想要进一步了解 Cursor 及其使用方法与最佳实践来提升编程效率

<!-- more -->


## 0. Insight

- Cursor 与传统 IDE 相比的核心优势，是做到了**足够优秀的人机交互和效果足够好的 LLM**
- Cursor 的**本质是基于 LLM 的交互工具**。它能够在很多场景下有效解决问题，尤其是快速代码开发、执行重复性任务、解决常见编程问题等，但 LLM 带来的局限性也很明显，如结果随机性、上下文窗口限制、无法创新以及缺乏垂直领域的深度知识等。这意味着它需要用户在使用过程中主动验证和调整，不能完全依赖
- Cursor 并**不是“银弹”**。它更适合快速实现 MVP、重复性任务的自动化、解决跨领域问题、中小型项目的开发与优化等。对于复杂的工程项目，Cursor 的使用门槛会显著提高，尤其是当需要高度定制化或深度专业知识时，它的表现往往会显得力不从心
- **当前最好的协作模式是“人工 + 半自动化”**。Cursor 可帮助用户完成大部分基础性和重复性工作，但当尝试让其完成更复杂或精确的任务时，用户需要投入大量精力进行提示工程和结果校验等。换句话说，从 80 分到 100 分的提升，成本和难度会成倍增加，尤其是在复杂场景下
- **Cursor 的价值在于辅助开发者，而非替代开发者**。不要期待它完全驾驭你的项目，而是需要你主动学习如何更好地驾驭它。这种“工具心态”能够帮助用户充分利用 Cursor，而不是对它产生不切实际的期待
- 对 Cursor 的**使用需要一种“降低预期，多一些耐心”的心态**。它并不是全能的解决方案，而是一个用好能大幅提升效率的工具。用户需要在使用过程中不断实践去试探其边界，找到适合自己的最佳使用方式

## 1. 引言：我眼中的 Cursor 从爆火到“祛魅”

> 从接触 Cursor 我大概经历了以下心路历程：爆火期—>体验期—>祛魅期—>理性期。

**——爆火期**

我第一次听到 cursor 是去年大概9月份左右开始，刷推特时就经常能看到类似如下的言论，特别是在11月份爆火：

- “我用 cursor 在 xx 小时内完成了某个项目或产品”
- “作为编程小白使用 cursor 在短时间内完成开发了一个 xx 项目或产品”
- .......（也不乏类似 “零编程经验的小学生/小朋友使用 cursor 完成上架了一款 xx 产品”）

然后就是在 youtube 上也开始看到不断涌现出现来的 cursor 教程以及 cursor 宣传视频。

本来一开始刷到的时候，我还是保持怀疑态度，比如 cursor 有这么厉害吗？为什么取代程序员的言论越来越多？

当时的我对 AI 编程的认知还是停留在代码补全、AI 聊天等， 还是不觉得能通过 AI 短时间内构建一个完整的项目。

---

**——体验期**

抱着试一试的态度，开始打开 cursor 官网，下载，进入界面（自动迁移我 vscode 插件），然后输入指令。
差不多就过了两个多小时的时间，我开发了以下内容：

- 一个类似补光灯的网页、一个简单图像压缩工具的网页、一个能格式化文本的 macos 应用
- 测试了下能基本使用，然后再加上这些项目的 readme 说明文档等
整个流程下来我没有真正意义上地写过一行代码，全程所做的动作就是

- 不断向对话框输入需求内容以及运行报错的问题（macos 应用还是需要在 xcode 上运行）
- 看着 cursor 在项目新建或修改文件，然后对它给出的代码进行 apply / accept

如果没有 cursor，对于 html、css、javascript 已经忘得差不多、以及零 swift 和零 macos 开发经验的我来说，我相信我如果要做到上面的内容，至少需要花上几天甚至几周的时间，这下大概能理解为什么会出现上面发生的事情了，这也确实给我带来了不小的震撼，因为从未想到有一个 AI 编程工具能够做到，整个项目维度的“补全”，而不只是某段代码的补全，在那一刻确实有一种被 AI 看来要取代程序员的想法了。

---

**——祛魅期**

但是事后冷静下来我还是对它“祛魅”了（在如今的1月份对早期接触 cursor 大部分人也是，特别是对于编程经验较为丰富的人），随着我持续的尝试和使用，开始意识到 cursor 还是摆脱不了目前 LLM 带来的局限，如随机性、无法创新、依赖上下文等，依然只能定位在“辅助编程”的角色，无法完全做到主导整个项目，特别是随着项目的复杂度（如功能逻辑、工程架构等）越来越高的时候，它的答案就变得不是那么智能了。

---

**——理性期**

虽然 cursor 存在着这样的短板，但是瑕不掩瑜，cursor 借助强大的 LLM 模型搭配优秀的交互，确实能够做到相较于之前的 AI 编程工具，极大地提升编程效率，以及解决绝大基础问题，这依然值得我们去了解和学习如何使用。下面我将会介绍 cursor 的基础使用以及适用场景和最佳实践等内容，来帮助大家学习如何使用 cursor 和加深其 AI 编程的理解。

## 2. Cursor 简介

> 官网地址：https://www.cursor.com/

### 2.1 核心理念

!!! "note"

    核心理念：在传统 IDE 的基础上，**增加了足够好的交互与足够好的LLM**

Cursor 是一款由 Anysphere 团队**开发的 AI 优先（AI-First）IDE**。与传统的 IDE 不同，它的核心设计理念并非单纯提供更强大的调试工具或插件生态，而是**将大语言模型（LLM）深度融入编程工作流**，试图重新定义开发者与代码的交互方式。

基于 Visual Studio Code 的底层架构修改而来，Cursor 继承了 VSCode 的扩展性和配置兼容性（用户可直接迁移原有插件和主题），但在此基础上构建了独特的**对话式编程体验。其本质是一个基于自然语言的代码生成与重构引擎，开发者可以通过自然语言指令直接操作代码库**。

### 2.2 核心功能与技术架构

Cursor 的能力可归纳为三个层级：

**1. 第一层：代码智能增强**

**动态代码生成**

- 支持通过自然语言描述生成代码片段（如函数、类、测试用例）
- 甚至能根据上下文自动补全未完成的逻辑

> 例如输入注释 // 用 Gin 实现用户注册接口，要求参数校验和数据库写入 → 生成完整路由处理函数（含结构体绑定和错误处理）

**语义级代码优化**

- 基于 LLM 理解代码意图后提供重构建议

> 例如将 golang 语言中多个同步逻辑的代码模块优化为使用 goroutines 协程的形式进行并发处理

**跨语言上下文感知**

- 在混合技术栈项目中（如前端 TypeScript + 后端 Golang）可以能根据其他文件的接口定义生成类型匹配的对应端的代码

> 例如在 golang 项目中定义路由 /api/users 能够自动生成前端的接口类型声明，并进行对应的调用（或 protobuf 声明类似）

**2. 第二层：开发流程再造**

**对话式问题解决**

- 开发者可直接将错误信息粘贴到聊天窗口，Cursor 会分析堆栈跟踪、定位问题根源并提供修复方案

> 例如粘贴错误 panic: runtime error: invalid memory address ..... ，可根据信息直接定位到空指针解引用并提供修复建议

**项目级知识管理**

- 通过持续学习当前项目的代码风格、技术规范（如通过 .eslintrc 或 pyproject.toml），生成符合团队约定的代码

> 例如根据项目中的 go.mod 依赖版本，生成兼容当前库版本的 API 调用示例（如 AWS SDK v2 操作 S3）

**3. 第三层：技术栈突破**

**多模态编程支持**

- 在最新版本中，Cursor 已开始支持草图转代码功能
- 同时也支持上传类似上传文档链接等形式生成代码

>
> - 上传一个网页线框图，可自动生成对应的 HTML/CSS 布局代码
> - 传 Swagger 文档，自动生成符合 OpenAPI 规范的 Gin 路由层代码（含参数校验中间件）

**私有模型混合部署**

- 企业用户可连接自有微调过的领域专用模型与通用 LLM 形成互补

> 例如添加已兼容 OpenAl 输入格式的模型，其中可参考的 Kimi、Deepseek 等兼容了该格式的模型

### 2.3 底层技术栈

Cursor 的技术实现可概括为：

1. **模型层**：主要依赖 GPT-4 系列模型，同时实验性集成 Claude、CodeLlama 等开源模型

2. **上下文管理**：采用向量数据库（Vector DB）实时索引项目文件，确保代码生成的上下文相关性

3. **安全沙箱**：所有 AI 生成的代码均在隔离环境中执行验证，防止恶意代码注入

这种架构使得 Cursor 在保持响应速度的同时，能够处理超过 50 个文件的上下文关联。

   - 比如远超普通聊天机器人 4-8k Token 的限制

!!! question

    扩展思考：为什么选择基于 VSCode 改造？

    1. **生态继承**：直接复用 VSCode 的 5 万+扩展插件，避免重复造轮子；
    2. **渐进增强**：开发者无需改变原有操作习惯即可体验 AI 功能；
    3. **性能保障**：VSCode 的轻量级架构（Electron + TypeScript）为实时 AI 推理提供基础支撑；


## 3. Cursor 的使用

### 3.1 界面介绍

![](https://img.zhengyua.cn/blog/202502161134815.png)

从上面图示可看到 cursor 的界面上实际就是在 vscode 基础上增加了右侧的 AI 对话框，分别对应以下模式：


**1. Chat（对话模式）：开放式编程助手**

- 支持自然语言对话（中英文混合输入）
- 可处理跨文件上下文（自动识别当前项目结构）
- 支持多轮追问（基于历史对话优化输出）

**2. Composer（代码生成器）：流程化代码构建**

- 分步骤代码生成（通过 `/generate` 命令触发）
- 提供选项式参数配置（如选择框架、语言版本）
- 支持模板保存与复用（`.cursor/templates` 目录）

**3. Bug Finder（智能诊断）：深度代码分析**

- 静态代码扫描（实时检测语法/类型错误）
- 运行时模式预判（识别潜在内存泄漏/竞态条件）
- 提供修复方案优先级排序（按严重性分级提示）


### 3.2 基础使用

这里我们以一个从0到1通过 Cursor 生成的 demo 项目来介绍其基础的使用。

并且以我**对于 0 swift 编程经验的视角来通过 cursor 实现一个 macos 上的应用**，该项目主要实现一个简单功能：

- 自动监听 mac 上剪贴板的内容，在复制粘贴内容时实现「中英文之间添加空格」的格式化处理

#### Composer

首先使用 xcode 来创建一个空的 DocumentApp，然后使用 cursor 打开该项目（文件均是 xcode 初始化生成）。

然后我们通过利用 Composer 开始进行对话，**直接向它描述我们所想要实现的诉求**：

![](https://img.zhengyua.cn/blog/202502161136934.png)

![](https://img.zhengyua.cn/blog/202502161136019.png)

然后你可以看到 cursor 会根据项目**直接对需要实现目标功能的多个文件按步骤修改，询问是否采纳其修改内容**。

当我们点击 accept all 后相当于同意其修改内容并进行保存，后续我们就可以直接在 xcode 上运行并确认是否正常。

![](https://img.zhengyua.cn/blog/202502161136391.png)

测试没有问题之后，我们还可以让它生成该项目的 README.md 文件，至此简单的 demo 项目就通过两步完成。

![](https://img.zhengyua.cn/blog/202502161137118.png)


#### Chat

如果我们此时想要了解该项目的目录架构含义以及最核心的文件，则可利用 Chat 进行询问：

![](https://img.zhengyua.cn/blog/202502161137530.png)

![](https://img.zhengyua.cn/blog/202502161137327.png)

#### BugFinder

接下来为使用该功能，故意删除一些关键代码然后启动 BugFinder 进行处理（注意使用时需按不同 git 版本 Run）：

> 实际上当出现 Bug 的时候也可直接通过 Composer 进行解决，它会根据你提供的报错内容进行修复。

![](https://img.zhengyua.cn/blog/202502161138052.png)

### 3.3 高阶使用

除了上面的基础应用，以下 cursor 目前使用较为频繁以及提升效果较好的高阶用法也需要我们了解：

#### 指定 Context

无论是在 chat 还是 composer 中我们可以指定多种类型的上下文信息来帮助 cursor 更好地理解诉求，比如以下：

![](https://img.zhengyua.cn/blog/202502161138404.png)

- **@Chat**：将当前聊天历史（对话记录）作为上下文，使 AI 能基于之前的问答逻辑继续响应
- **@Code**：引用选中的代码片段（如函数、类或变量），作为核心上下文供 AI 分析
- **@Codebase**：自动扫描整个项目代码库，根据当前问题动态筛选并排序相关文件或代码
- **@Definitions**：提取光标附近的代码定义（如函数声明、类接口）作为上下文
- **@Docs**：引用项目内或已索引的第三方文档（如 API 文档、Markdown 文件）作为上下文来源
- **@Files**：将整个文件内容作为上下文，支持跨文件引用（如配置文件、核心模块）
- **@Folders**：引用整个文件夹内的代码，适用于需要长上下文的跨文件逻辑分析
- **@Git**：集成 Git 仓库信息（提交记录、代码差异、PR 描述）作为上下文
- **@Link**：解析外部链接内容（如 GitHub 仓库、技术文章），提取文本作为上下文
- **@Web**：通过搜索引擎查找与问题相关的公开信息（如错误解决方案、最新技术文档）

其中具体操作需要知道的是：

- **添加方式**：通过界面中的「Add Context」菜单或命令面板选择上下文类型
- **动态组合**：可混合多种上下文（如 @Code + @Docs 生成符合文档的代码）
- **智能排序**：系统会基于问题相关性自动调整上下文权重（如 @Codebase 优先加载高频调用的文件）

#### Rules For AI

Cursor **允许用户自定义的 AI 行为约束规则即「Rules For AI」，可以理解为 cursor 设置的提示词 Prompt**。

目前 cursor 支持在全局粒度（左图）或者项目粒度（右图）中进行定义，如下所示：

![](https://img.zhengyua.cn/blog/202502161139684.png)

![](https://img.zhengyua.cn/blog/202502161139911.png)

通过该功能可以更好地控制 AI 输出方式和规范，确保生成的代码或建议更符合项目需求、团队风格或开发规范等。

目前网上也有许多可以参考的预设模版帮助你进行设置：

- https://cursor.directory/
- https://www.bookai.top/cursor/Cursor-Prompt/cursor-system-prompt
- https://marketplace.visualstudio.com/items?itemName=KevinKern.cursorrules-search

#### 其他

除了上面提到的功能，目前 cursor settings 也有一些额外的选项和可探索的 features，比如：

- **选择其他模型**以及可支持接入符合如 OpenAIAPI、AzureAPI 等不同规范的模型

![](https://img.zhengyua.cn/blog/202502161140601.png)

![](https://img.zhengyua.cn/blog/202502161140084.png)

- **自动分析代码库上下文**，帮助提升 AI 生成代码的准确性和相关性

![](https://img.zhengyua.cn/blog/202502161140127.png)

- 支持**接入 MCP Servers 来**集中管理 AI 交互的上下文、规则和资源

![](https://img.zhengyua.cn/blog/202502161141099.png)

- 同时还能够扩展支持浏览器搜索、网页浏览以及集成内部组件等

## 4. Cursor 的适用场景与短板

### 4.1 适用场景

基于上面的了解其实也不难发现 cursor 的强大之处除了使用了目前强大的语言模型（公域知识），还有就是**在“人机编程的交互”以及“仓库层面的理解（私域知识）”做到了非常好的效果**。结合我实际的体验效果来看，我理解 cursor 比较适合以下场景：

1. 快速原型的开发（MVP 版本）
2. 重复性任务的自动化（如代码模板生成和文档生成，特别是像生成单测以及翻译不同编程语言等需求）
3. 中小型项目或者说中等复杂问题的开发与优化
4. 集合问答等其他功能的“沉浸式一体化” AI 编程

### 4.2 短板

**cursor 的短板实际主要就是 LLM 的短板**，cursor 的能力边界也是 LLM 的能力边界：

- 数据驱动的局限：无法超越训练数据的覆盖范围，缺乏特定领域知识；
- 模式学习的局限：推理基于模式匹配，缺乏逻辑演绎和因果推理能力；
- 生成机制的局限：输出基于概率分布，缺乏高精度和一致性；
- 记忆机制的局限：缺乏长期记忆和动态交互能力；
- 认知能力的局限：无法主动探索未知或进行原创性创新；

所以站在 cursor 也很难处理好对**实时性要求高、高精准度、上下文长度限制、复杂领域知识**等问题。

!!! note "LLM 的本质能力是基于**语言模式学习和生成**"

    - 通过对自然语言的词语分布、上下文关联和语义模式的学习，完成看似“理解”和“推理”的任务
    （通过大规模语言数据的统计模式学习，生成语言输出并表现出一定程度的语义理解和推理能力）

    需要注意的是：

    - **语言理解**：LLM 并非真正理解语言，而是通过统计规律模拟出类似理解的表现
    - **推理能力**：LLM 能够完成简单的关联性推理和模式匹配，但在复杂的逻辑推理、长链推理和因果推理上表现较弱

除此之外，输入给 cursor 的 prompt 和大模型的质量也会直接影响 cursor 的输出效果。


## 5. Cursor 的最佳实践

### 5.1 谨慎采纳生成的代码

- 谨慎直接采用 cursor 生成的代码文件，最好是结合上下文做好 CodeReview 工作，保证结果正确且长期可维护
- 在实际使用过程中，谨慎使用“Apply”和“Accept”功能，更多先使用 Save All 进行验证后，出现问题使用 Reject

### 5.2 结合 LLM 的良好交互习惯

cursor 的使用摆脱不了对 LLM 的使用，所以一些 LLM 良好交互的共性知识是可以复用来优化输出效果的：

- 结合 Cursor Rules 的提示工程，设计清晰和具体的提示词能够得到更高质量的内容输出
- 需要注意如何描述清楚你的需求，也是非常重要的一环，这也是与 LLM 进行交互的共性问题
- 结合 cursor 更擅长解决中小型问题的特点，将需求进行拆解，聚焦更小的粒度来获得更集中的输出

### 5.3 做好备份

考虑到 cursor 或者说 LLM 的随机性，可能会无意删除或增加一些有问题的代码，特别是在项目代码量逐渐庞大之后，触发的概率可能会更高，所以我们在应用 Cursor 时，特别是关键的代码文件，提前做好备份以防止意外覆盖，比如使用 git 的版本管理，频繁去提交代码进行保存。

### 5.4 结合私域知识拓展

cursor 所带来的仓库级别的理解能力，弥补了当前模型仅有公共知识领域的局限，结合仓库私域知识我们可以做到：

- 生成质量更高的项目 README 文档，提升文档编写效率
- 总结更聚焦于该仓库代码的共性知识和核心实现等，方便更好地理解和提取仓库的知识

### 5.5 安全问题

我们需要注意到 cursor 并不是完全本地，所以理论上使用 cursor 打开项目是会有源码泄露的安全问题。

即使是目前 cursor 中有 privacy mode，也很难去保证没有类似的安全问题，特别是公司内部的场景。

## 参考

[AI 代码编程助手真的有用吗](https://agijuejin.feishu.cn/wiki/Uos4wUk3miQG0pkoCtmcQnWanug)

[Cursor - 将为软件开发行业带来深刻变革](https://agijuejin.feishu.cn/wiki/NpPrwKAAMi0rQ0kZacgc3YKCnle?from=from_copylink)

https://juejin.cn/post/7414541124666851355