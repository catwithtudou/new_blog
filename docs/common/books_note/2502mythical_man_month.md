# 25.02《人月神话》阅读笔记下(08~)

## 第8章 胸有成竹

> 经验是昂贵的老师，但愚人只能从经验学习。 -- 穷查理年鉴

对于估计一项系统编程任务的工作量，我们通常可通过经验发现：

- **工作量是程序规模的幂函数**

![](https://img.zhengyua.cn/blog/202502211025728.png)

作者在本章列举了多个组织关于程序员生产率的研究例子，来对此进行延伸。

**1. Portman 的数据**

该团队发现的观点是：

- 编程团队的进度大约是计划进度的 1/2，每项工作花费的时间大约是估计的2倍

简言之，项目估算对**每个人年的技术工作时间数量做出了不现实的假设**。

**2. Aron 的数据**

根据程序员（和系统部件）之间的交互划分这些系统得到如下的生产率：

- 非常少的交互：10000 指令/人年
- 少量的交互：5000 指令/人年
- 较多的交互：1500 指令/人年

该数据未包含支持和系统测试活动，仅仅是设计和编程。

**3. Harr 的数据**

**没有人可以完全确定**程序复杂程度和人员数量等因素所导致的生产率差别。除开这些不确定性，数据反映了实际的生产率。

![](https://img.zhengyua.cn/blog/202502211030240.png)



**4. OS/360 的数据**

OS/360 以及前面的数据基本都能证实**生产率会根据任务本身的复杂度和困难程度表现出显著差异**。对此作者给到的经验准则是：

- 在估计复杂性的混乱中，**编译器的复杂度是正常批处理程序的3倍，操作系统复杂度是编译器的3倍**

**5. Corbato 的数据**

该组织得到的关键结论是：

- **对基本语句而言，生产率似乎是恒定的**。考虑到语句所需要的思考和可能包含的错误，这个结论是合理的
- 使用适当的高级语言，**编程的生产率可以提高5倍**


??? note "以下是 LLM 补充的思考和看法"


    === "deepseek-r1"


        你的总结已经非常全面，我尝试从现代视角和延伸思考的角度补充一些观点，帮助深化理解：

        ---

        延伸思考与补充视角

        1. **「人月神话」的核心矛盾再审视**

        第八章的数据本质上揭示了软件工程中一个永恒矛盾——**「人月」是否可以作为可叠加的线性单位**。Portman 发现的「实际耗时是估算的2倍」，本质上暴露了「人月神话」的核心：

        - **沟通成本的非线性增长**（布鲁克斯定律的前兆）：人数增加时，沟通路径呈组合数增长（n(n-1)/2），但管理者常误以为人力是可线性叠加的资源。
        - **认知负荷的隐蔽性**：代码复杂度带来的认知负担难以量化，比如Aron数据中「较多交互」导致生产率骤降67%，这实际上反映了模块间耦合度对心智模型的破坏。

        2. **复杂度度量的现代演进**

        作者提到的「编译器复杂度是批处理程序的3倍」基于1970年代的系统，今天的复杂度维度已发生变化：

        - **分布式系统的「暗物质复杂度」**：微服务、云原生架构引入了网络延迟、容错、一致性等新复杂度轴，传统代码行数（LOC）的度量完全失效。

        - **康威定律的显性化**：系统设计受制于组织架构（如微服务团队自治），交互成本从「代码耦合」转移到「API契约治理」，Aron的「交互等级」需要重新定义。


        3. **高级语言的「5倍效率」再思考**

        Corbato的数据显示高级语言提升效率，但这一结论需要辩证看待：

        - **抽象的双刃剑**：现代语言（如Rust/Python）确实提升编码效率，但过度抽象可能导致调试难度指数级上升（例如Python动态类型的运行时错误）。

        - **AI代码补全的变量**：GitHub Copilot等工具可能将「语句级生产率恒定」提升到「功能块级恒定」，但需警惕生成代码的认知盲区。


        4. **被忽视的「隐性时间黑洞」**

        原始数据未充分纳入的关键因素：

        - **「隐形20%」**：调试、文档、兼容性适配等非编码任务，在现代工程中占比可能超过50%（尤其是开源依赖管理）。

        - **上下文切换成本**：多任务并行导致的注意力残留（参考《深度工作》），这在敏捷开发中尤为明显。


        5. **现代估算模型的进化**

        从作者时代的经验公式到今天的科学方法：

        - **COCOMO II模型**：引入「早期设计」与「后架构」阶段的不同权重，量化需求稳定性、团队经验等因素。

        - **概率性估算**：如蒙特卡洛模拟替代单一估算，通过区间分布（如「最快-最可能-最慢」）管理预期。

        - **敏捷度量**：用「故事点」替代人天，通过迭代Velocity动态校准，避免过早精确化导致的谬误。

        ---

        行动建议（如何应用这些洞见）

        1. **反直觉决策**

        - 面对延迟时，避免盲目加人，优先考虑**减少交互成本**（如重构模块边界、引入Facade模式）。
        - 用「复杂度税」机制：强制要求每个新增模块的提案者举证其对全局复杂度的贡献。

        2. **量化沟通负载**

        - 在WBS中增加「协调积分」，例如：每周会议时长×参与人数²，作为项目健康度的预警指标。

        3. **语言与工具策略**

        - 对胶水代码使用高阶语言（Python），对核心模块用高性能语言（Rust），平衡效率与质量。

        - 建立「技术雷达」机制，持续评估AI编码工具的真实ROI（如生成代码的维护成本）。

        4. **复杂性免疫设计**

        - 采用「逆康威策略」：先定义理想的系统架构，再调整团队组织结构与之匹配。
        - 推行「无接口不编码」：强制要求模块间通过显式API/契约交互，降低隐性耦合。

        ---

        经典案例对照

        - **Linux内核**：通过高度模块化和「树状维护者结构」，在超大规模下保持较低交互成本（印证Aron的「交互量级」理论）。
        - **SpaceX发射软件**：极端强调自动化测试（每行代码对应17个测试用例），将后期调试成本提前摊薄，间接提升「人月效率」。

        你的总结已抓住核心，以上补充试图连接经典理论与现代实践，或许能带来新的启发。


    === "gpt4-o"

        你的总结非常清晰地概述了第八章《胸有成竹》的内容，尤其对不同组织的数据归纳和关键结论的提炼十分到位。以下是一些补充的看法和延伸思考，帮助进一步理解和反思这部分内容：

        ---

        **补充思考 1：工作量是程序规模的幂函数**

        a. **复杂度的非线性增长**

        代码行数的增加与工作量的指数型关系揭示了软件开发中“复杂性成本”的核心问题。随着代码规模变大，团队需要处理的**模块间的交互**、**依赖性管理**以及**认知负荷**都会显著增加。这种非线性关系提醒我们：

        - 软件开发不能简单地通过人力堆叠来解决问题，特别是当团队规模增长后，管理成本也会随之增加（如《人月神话》的核心观点之一：人月不可叠加）。

        - 为了减少复杂性增长带来的成本，需要在架构设计阶段进行深入的**模块化设计**，尽量将系统分解为独立的、低耦合的模块。

        b. **与现代敏捷开发的联系**


        在敏捷开发中，通过短周期迭代（如 Scrum 的 Sprint）将任务分解为小规模、独立的功能模块，可以有效降低工作量的非线性增长效应。这与本章提出的“任务复杂性与工作量幂函数关系”的观点形成了实践上的呼应。

        ---

        **补充思考 2：关于生产率的多维数据分析**


        a. **不同数据来源的互补性**

        你总结的 Portman、Aron、Harr、Corbato 等数据从不同角度揭示了**生产率的变量**：

        - “**人与人之间的交互**”是生产率降低的主要因素之一。Aron 的数据表明，交互越复杂，生产率越低。这可以联想到现代软件工程中“沟通成本”的问题。团队规模越大，沟通和协作的效率越低。

        - Corbato 的结论中提到，**高级语言可以提高生产率**，这与现代开发中“工具和技术选型”的重要性一致。例如，使用高效的框架、自动化工具和代码生成器可以显著提高生产效率。

        b. **实践中的应用**

        这些数据可以帮助我们在项目管理中做出更合理的决策：

        - 小团队适合处理高交互、复杂度高的模块，而大型团队适合处理独立性强的模块。

        - 在项目预算和工期估算时，需要对任务的复杂度进行量化评估，而不能单纯基于代码行数或功能点。

        - **现代视角的验证**

        自《人月神话》发表以来，软件开发的生产率随着工具、方法和技术的进步不断提高。例如，现代 IDE（集成开发环境）和 CI/CD 流水线已经显著减少了开发和测试的时间。然而，尽管工具提高了生产率，复杂性依然是阻碍效率的首要因素，这说明书中的观点仍然具有深远意义。

        ---

        **补充思考 3：OS/360 数据与复杂度评估**

        - **复杂度的经验准则**

        OS/360 的数据提出“编译器复杂度是批处理程序的 3 倍，操作系统复杂度是编译器的 3 倍”。这是一种基于经验的复杂度分层模型。尽管现代软件的复杂性已经远超当年，但这种分层模型仍然可以作为一种**估算复杂度的指导原则**。

        - **复杂度对错误率的影响**

        系统复杂度的增加不仅显著影响生产率，还会导致错误率的非线性增长。复杂系统中的 bug 通常具有隐蔽性和多样性，这使得调试和修复的工作量也指数型增加。因此，现代软件开发更加强调**自动化测试**和**持续集成**，以尽早发现和解决问题。

        ---

        **补充思考 4：高级语言与生产率**

        a. **编程语言的生产率提升**

        Corbato 的研究表明，使用高级语言可以提高 5 倍生产率。这一结论在现代软件开发中有了更多实践支持，例如：

        - 高级语言（如 Python、Kotlin、Swift）相比低级语言（如 C、Assembly）在语法简洁性、内置库和开发效率上表现突出。
        - 高级语言使开发者可以专注于业务逻辑，而非底层实现。

        b. **生产率与错误率的权衡**

        高级语言虽然提高了生产率，但也可能因为其抽象程度更高而隐藏一些潜在问题。例如，垃圾回收机制虽然减少了手动内存管理，但也可能导致性能问题。如果对性能和可靠性有极高要求，开发者依然需要理解底层实现。这种权衡提醒我们，语言的选择应根据项目需求而定，而不是一味追求生产率。

        ---

        **延伸思考：结合现代软件工程的启示**

        a. **自动化工具的应用**

        本章提到的生产率提升因素，如高级语言和减少交互复杂度，在现代开发中可以通过更广泛的自动化工具实现：

        - **代码生成工具**：如 Swagger 可以自动生成 API 接口代码，减少重复劳动。
        - **测试框架**：如 JUnit、pytest 等，缩短测试时间并提升代码质量。
        - **DevOps 流程**：通过持续集成、自动化部署，减少交付周期，提高效率。

        b. **数据驱动的开发管理**

        Harr 的数据强调了生产率的不可预测性，这与现代数据驱动的开发管理形成对比。通过分析开发过程的指标（如代码提交频率、构建失败率、平均调试时间等），我们可以更精确地预测项目进度并进行调整。

        c. **跨学科的协作**

        现代软件开发团队通常由开发、测试、运维、产品经理等多角色组成。如何减少这些角色之间的沟通成本，是提升生产率的关键。敏捷开发中的“每日站会”和“透明化看板”正是应对这些问题的有效实践。

        ---

        **总结**

        第八章通过数据和经验揭示了编程任务的复杂性与生产率的关系，这些观点在今天仍然具有指导意义。结合现代软件开发工具与方法，我们可以更好地理解和实践这些理论。关键在于：

        1. **合理评估复杂性**，避免低估工作量。
        2. **优化团队协作**，减少交互成本。
        3. **善用工具和高级语言**，提升生产率。
        4. **拥抱自动化与数据驱动**，提高开发过程的可预测性。

## 第9章 削足适履

> 作者应该看看诺亚，向他学习，像他在方舟中所做的那样，把大量的东西挤到一个非常小的容器内。 -- 西德尼·史密斯，《爱丁堡评论》

**1. 作为成本的程序空间**

- 程序的成本除了运行时间以外，**所占据的空间也是主要开销**
- 应该从整体上进行评价，不仅仅是提倡更紧密的软硬件设计集成，还有规模本身对软件系统的影响
- 规模也会占据成本较大的部分，所以建造者需要**设置规模的目标，控制规模并考虑减少规模的方法**，同任务开销一样，规模本身不是坏事，但不必要的规模是不可取的

**2. 规模控制**


- 对项目经理而言，规模控制不仅是技术工作的一部分，也是**管理工作的一部分**，他必须研究用户及其应用，以设置待开发系统的规模。“规模-速度”权衡方案结构会很大范围内变化，所以需要了解每一小片内可用的权衡

作者就规模控制来说列举了在 OS/360 项目学习到的经验：

- 和制定驻留空间预算一样，**应该制定总体规模的预算**；和制定规模预算一样，应该制定后台存储访问的预算
- 在规定模块有多大的同时，**确切定义模块的功能**
- 在项目规模本身很大的前提下，缺乏管理和沟通导致团队成员认为自己是争取小红花的学生**而不是产品的建造者**

**3. 空间技能**

空间预算的多少和控制并不会减少程序规模，而是需要其他的手段来帮助实现：

- **用功能换空间**，考虑为用户保留多少选择，即用户可选项目的粗细程度
- **空间与实践的折中**，依据通常对于给定的功能空间越多则速度越快的信息，经理可通过**培训团队成员的编程技能**（而不是仅仅依赖天赋和先前的经验）和让团队成员意识到**编程有技术性**需要开发很多公共单元构件的两种方案来帮助取得折中

**4. 表达是编程的本质**

超越技艺的是创新，而创新的结构几乎都是从**战略上突破的**，而不是战术上的聪明。而更普遍的是战略上的突破常**来自数据或表的重新表达**（程序的核心所在），作者通过提到的 IBM 650 建造精密的控制台解释器、 Fortran 编译器等例子来说明**表达的力量。**

- 当程序员因空间不足而束手无策的时候，通常最好的办法就是从自己的代码中挣脱出来，放松一下，**思考自己的数据**。表达是编程的本质。


??? note "以下是 LLM 补充的思考和看法"


    您的总结很全面地覆盖了《人月神话》第九章"削足适履"的关键内容。我可以提供一些补充思考和现代视角，帮助您加深理解：

    **现代视角下的思考与启示**

    **1. 空间成本的演变**

    虽然今天的硬件资源已远超Brooks时代，但"空间成本"这一概念依然重要：

    - 移动设备和嵌入式系统仍然面临资源限制
    - 云计算环境下，资源使用直接转化为经济成本
    - 网络传输带宽和延迟对于web应用和分布式系统至关重要
    - 能耗考量（尤其在数据中心和移动设备）成为新的"空间成本"维度

    **2. 规模控制的深层意义**

    Brooks将规模控制视为管理工作的部分，这一观点有着深远意义：

    - 复杂性管理：软件规模增长往往导致复杂性指数级增长
    - 技术债务：未控制的规模常常累积技术债务，长期影响开发效率
    - 团队心理学角度：大型项目中的"争小红花"现象反映了团队认同感缺失问题
    - DevOps文化强调的"小批量、频繁发布"策略实际上是规模控制的现代体现

    **3. "表达是编程的本质"的哲学深度**

    这句话包含了编程的哲学核心：

    - 程序本质上是对现实问题的形式化表达
    - 数据结构的选择往往比算法优化更能决定程序效率
    - 领域特定语言(DSL)的兴起体现了表达力对生产力的影响
    - 函数式编程的流行部分源于其提供了更简洁、更强大的表达方式

    **4. 与现代软件工程实践的连接**

    Brooks的思想与当代实践有许多共鸣：

    - 微服务架构可视为"用功能换空间"的现代实践
    - 容器化和serverless技术提供了资源使用的精细控制
    - 代码重构和设计模式是"空间与实践的折中"的具体体现
    - 敏捷开发中的"极简可行产品"(MVP)思想与规模控制理念一脉相承

    **5. 对个人开发者的启示**

    - 在开始写代码前，投入足够时间思考数据表达和结构设计
    - 定期回顾项目范围，避免功能蔓延
    - 培养对复杂性的敏感度，追求简洁解决方案
    - 了解技术选择背后的资源消耗和成本含义

    Brooks在半个世纪前提出的这些观点，在当代软件开发中依然闪烁着智慧的光芒。无论技术如何发展，对空间的重视、规模的控制以及表达力的追求，仍然是软件工程的永恒主题。



## 第10章 提纲挈领

> 前提：在堆积如山的文件资料中，少数文档是关键枢纽，每一件项目管理的工作都围绕着它们运转。这些文档是项目经理最重要的个人工具。

**文档的工作是每个项目经理绕不开的事情**，文档的表达体现了他的管理工作和明确意见等大部分的工作内容，为了阐明软件项目如何开展该类工作，作者首先通过借鉴其他行业的文档资料来帮助进行归纳和得出结论：

**1. 计算机产品的文档**

制造一台机器关键的文档通常会有：

- 目标|规约|进度|预算|组织结构图|工作时间的分配
- **估算&预测&价格**：三因素环状互锁，决定项目的成败
    -  如果价格低于假设值，好的螺旋开始，往预测值上升->单元成本下降->价格下降
    -  如果价格高于假设值，坏的螺旋开始，需要做到成本必须降低来获得更低的预算

![](https://img.zhengyua.cn/blog/202502262008296.png)

**2. 大学科系的文档**

尽管目的和活动存在差异，但**数量类似、内容相近**的各类文档形成大学的主要资料集合：

- 目标|课程描述|学位要求|研究提案|课程表和教学安排|预算|空间分配|工作人员和研究生的分配

注意这些文档的组成与计算机项目非常相似，此相似不是偶然而是：

- **任何管理任务的关注点都是时间、地点、人员、项目内容和资金**


**3. 软件项目的文档**

不论项目的规模，经理聪明的做法都是**立刻开始制定若干微型文档，以作为自己的数据基础**，且事实证明其文档与其他领域经理所需的文档都非常类似：

- 内容：目标和产品规约|时间：进度表|资金：预算|地点：空间分配|人员：组织图

**4. 为什么要有正式的文档？**

作者给出的主要理由有三个：

- **书面记录决策是必要的**，只有记录下来，分歧才会明朗，矛盾才会突出，从而帮助识别清晰和确定的政策
- **文档能够作为同其他人沟通的渠道**，帮助经理减轻沟通的负担，从而对齐团队内部成员的常识
- **可以作为数据基础和检查列表**，通过周期性回顾清楚项目所处状态以及需要调整的重点

经理的任务是制定计划并实现计划，但**只有书面计划是精确和可以沟通的，这些少量的关键文档封装了其大部分工作**。若一开始认识其普遍性和重要性，经理则将它们视为良好的工具而不是繁琐的琐事，以此更清晰和更快速地设定自己的方向。


??? note "以下是 LLM 补充的思考和看法"

    你对《人月神话》第十章的总结非常全面。我来补充一些思考，帮助你加深理解：

    **文档作为思维工具**

    Brooks 在这一章强调的不仅是文档的记录功能，更是文档作为"思维工具"的价值。当我们将想法书面化，实际上是在强迫自己进行结构化思考。很多不清晰的想法在写下来的过程中会被迫变得清晰，这也解释了为什么他认为"书面记录决策是必要的"。

    **文档的演化特性**

    值得注意的是，Brooks 隐含了这些文档并非一成不变的，而是随项目发展不断演化的。好的文档系统应该是"活"的，能够反映项目的当前状态和历史决策路径。许多项目失败正是因为文档被视为一次性工作，而非持续更新的工具。

    **文档与团队规模的关系**

    当团队规模扩大，正式文档的重要性呈指数级增长。在小团队中，非正式沟通可能足够，但随着规模增长，没有正式文档作为"事实来源"，团队成员会基于不同的理解和假设工作，导致混乱和重做。

    **文档的精简原则**

    Brooks提到"微型文档"这一概念非常关键。他主张文档应当精简、聚焦，而非冗长详尽。这一观点与现代敏捷方法论中"足够好的文档"理念一致，即文档应当满足当前需求，而不是追求完美或过度详细。

    **预算-预测-价格的循环与今日项目管理**

    Brooks描述的这种循环关系在今天的产品开发中依然适用。许多现代创业公司通过"正向循环"取得成功：合理定价→更多用户→规模经济→降低成本→更有竞争力的价格。这表明Brooks的见解超越了时代局限。

    **文档与现代项目管理工具**

    在今天，很多项目管理软件（如JIRA、Notion等）将Brooks描述的文档整合到数字化工作流中。但核心原则不变—我们仍需那些关键的"提纲挈领"式文档作为项目的骨架。技术只是载体变了，文档的本质功能没变。

    **战略思考与执行分离**

    Brooks强调的文档实际上代表了战略思考与日常执行的分离。经理需要这些文档来"升高视角"，避免陷入日常细节而忽视全局。这一点在今天"战略思考"与"战术执行"的管理理论中仍然重要。

    **结语**

    Brooks在1975年提出的这些观点至今仍有强大的指导意义。随着软件项目越来越复杂，保持关键文档的简洁性和更新性变得更为重要。我们可以借助新工具，但不能忘记文档的核心目的：帮助我们思考、沟通和协作。


## 第11章 未雨绸缪

> 不变只是愿望，变化才是永恒。 ——斯威夫特
>
> 普遍的做法是，选择一种方法，试试看；如果失败了，没关系，再试试别的方法。不管怎么样，重要的是先去常识。 ——富兰克林·罗斯福

作者通过**化学工程中的试验性工厂**的例子来说明在软件系统的构建人员也面临类似的问题。所以基于在第一次开发会遇到的未知问题和新系统概念或技术的经验，说明构建一个用来抛弃的系统是必须的。

所以管理上的问题不再是“是否构建一个试验性的系统，然后抛弃它”，而是必须这样做。现在的问题是”是否预先计划抛弃原型的开发，或者是否将该原型发布给用户“，我们可清晰地知道若选择后者虽然可带来时间，但对于用户的使用体验极差、影响产品声誉等诸多影响。

因此最关键的教训就是：**为舍弃而计划，无论如何，你一定得这样做。**

!!! abstract "**#1 唯一不变的就是变化变身**"

当拥有一切都会重新设计的变更思想，那么面对整个变化现象是非常有用的。而第一步就是接受这样的事实：

- **变化是与身俱来的，不是不合时宜和令人生厌的异常情况**

目标上的变化不可避免，事先对此做准备总比假设不会出现要好得多。不但目标上的变化不可避免，而且变化本身也不可避免，而且设计策略和技术上的变化也不可避免：

- **抛弃原型概念变身就是对事实的接受——随着学习的过程更改设计**

!!! abstract "**#2 为变更设计系统**"

如何为变化设计系统？实际在本书被普遍讨论，比如：

- 细致的模块化，可扩展的函数，完整的模块间设计和完备的文档
- 同时可能会包含调用队列和表驱动的一些技术等
- 最重要的措施是**使用高级语言和自文档技术**，以减少变更引起的错误，如在编译时的操作整合标准声明。
- 产品的数字版本，每个版本的日程表和冻结日期等

**变更的阶段化是一种必要的技术**需要我们掌握。


!!! abstract "**#3 为变更计划组织架构**"

作者提到Cosgrove主张把所有计划、里程碑和日程都当**做尝试性的以方便进行变化**。此做法可能有些极端，但现在软件编程小组失败的主要原因是管理控制得太少，而不是太多。

> 同时他还观察到，不愿意为设计书写文档的原因，不仅仅是惰性或时间压力等，也有不愿意提交尝试性的设计决策来进行辩解和被威胁。

**为变更组建团队比为变更进行设计更加困难**。通常会遇到管理人员和技术人员的区分，而只要天赋允许则在老板的视角会关注和培养两者的互换性，而这实践的过程会遇到很多社会性的阻碍如：

- 管理人员被认为高级人员太有价值，**而不舍得让其从事实际编程工作**
- 管理人员拥有**更高的威信**

为解决这些障碍，作者列举了某些实验室直接废除所有职位头衔，而如 IBM 则保持了两条晋升线：

![](https://img.zhengyua.cn/blog/202502271051420.png)

薪水级别很容易建立一致，但**建立一致的威信则比较困难**。从技术线向管理线同级调动的时候，不能伴随待遇的提升，即以“调动”的名义。

针对管理人员和技术人才这样的高层人员，目标信息和管理问题等必须得到共享，只要能力允许，必须时刻做好技术和情感上的准备，**能做到管理团队或亲自参与开发工作**。组建外科手术队伍式的团队的整体观念是对上述问题的彻底冲击，以此在高层人员实际亲自参与开发工作时不会感到自降身份，**清除剥夺创造性工作的乐趣的社会障碍**。

上述组织架构设计是为了最小化成员间的接口，也使系统在最大限度上易于修改，能够作为一个长期、有效、灵活的组织构建方案。

!!! abstract "**#4 前进两步，后退一步**"

程序发布后的变更通常被称为“**程序维护**”，当然也分不同的维护——硬件和软件维护。通常软件维护主要是**对设计缺陷的修复**，相较于硬件，软件变更通常新增功能更多且用户能够察觉到。

针对维护总成本，通常是开发成本的40%甚至更多，该成本还受用户数量的影响，作者还提到了以下规律：

![](https://img.zhengyua.cn/blog/202502280946437.png)

- 程序维护中的一个基本问题：**缺陷修复总会以固定的（20%~50%）的概率引入新的 Bug，即前进两步，退后一步**

为什么缺陷不能彻底修复的原因，主要是通常**某些微小不明显的错误实际上会影响整个系统**，其次维护人员通常也不是实现人员。

如果能**使用消除或至少能指明副作用的程序设计方法**，会在维护成本上有很大回报，同样错误出现的概率也和程序的体量有关系。

!!! abstract "**#5 前进一步，后退一步**"

作者通过列举 Lehman 和 Belady 研究的规律来说明所谓的“前进一步，后退一步”：

- 模块总数量随版本号的增加呈线性增长，但是受到影响的模块数量**随版本号的增加呈指数增长**
- 所有的修改都倾向于破**坏系统的架构**，增加系统的混乱程度（熵），随着时间推移系统变得越来越无序
- 修复原有设计瑕疵的工作越来越少，而**早期维护活动本身所引起的漏洞的修复工作**越来越多

> "事物在最初总是最好的。"


**系统软件开发是减少混乱程序的过程**，**所以本身是处于亚稳态的**。**软件维护是提高混乱度的过程**，即使是熟练的软件维护工作，也只是**放缓了系统退化到非稳态**的进程。


??? note "以下是 LLM 补充的思考和看法"

    以下是对你总结的补充思考与延伸，尝试结合软件工程发展现状与原书观点的碰撞，提供一些视角供你参考：

    ---

    **关于「试验性系统」的现代演绎**

    原书强调必须构建「可抛弃的原型」，这与今天的**MVP（最小可行产品）**概念高度契合。但现实中很多团队陷入误区：

    - **MVP ≠ 低质量原型**。真正的MVP应具备核心价值且代码可扩展，例如Twitter早期仅支持发140字文本，但架构设计预留了接口扩展性。
    - **何时该「舍弃」原型？** 现实中常因资源压力直接迭代原型，导致技术债堆积。Netflix曾因早期PHP架构无法扩展，被迫彻底重写为微服务，印证了「计划舍弃」的必要性。

    ---

    **关于「为变更设计系统」的实践矛盾**

    原书提出的模块化、文档化仍是黄金法则，但需警惕：

    - **过度设计的陷阱**：Airbnb曾因过早抽象「房源」模块导致后续国际化改造困难，证明模块边界需**平衡抽象与具体业务**。
    - **文档的现代困境**：自文档代码（如Python Type Hints）确实有效，但文档的维护成本依然存在。像Uber采用代码即文档（Swagger+API First Design），通过工具链自动化生成文档，可能更符合原书主张的「减少变更成本」。

    ---

    **组织架构变革的当代验证**

    原书提到的双线晋升机制，在Google的「Individual Contributor (IC)」与「Manager」双轨制中得到完美实践：

    - **技术领袖的回归**：Google Fellow Jeff Dean至今仍参与核心代码开发，证明**技术威信与管理职级的解耦**是可行的。
    - **外科手术团队的进化**：微软Azure某团队实践「**内部开源模式**」，核心架构师像「开源维护者」一样Review所有提交，既保留权威性又避免与社会障碍冲突。

    ---

    **维护熵增理论的残酷现实**

    Lehman的「熵增定律」在遗留系统中尤为明显，但现代方法论提供了新思路：

    - **混沌工程的启示**：Netflix的Chaos Monkey主动注入故障，其实质是通过**可控的破坏延缓系统无序化**。
    - **Serverless的悖论**：无服务器架构看似降低维护成本，但黑盒化反而可能加剧「改不动」的熵增。需警惕新技术对架构透明度的侵蚀。

    ---

    **一个反直觉的思考：是否所有系统都值得「长期维护」？**

    原书假设系统需要持续演进，但现代SaaS领域出现新趋势：

    - **定向生命周期设计**：Slack某些功能模块采用「一次性代码」策略，预期3年后直接废弃而非迭代。
    - **生态位系统的启示**：像Redis这类基础设施必须抵抗熵增，但业务系统可能更适合定期重构甚至重写。

    ---

    **终极问题：如何量化「可变更性」？**

    作者强调为变更设计，但未给出评估标准。现代软件工程尝试用指标衡量：

    - **架构适应度函数**（如ThoughtWorks提出的）：通过自动化测试监控架构约束，例如「服务间依赖不得超过三层」。
    - **代码腐化度模型**：SonarQube等工具用圈复杂度、重复率等指标预警熵增临界点。

    ---

    这些思考或许能帮助你跳出原书的时代局限（毕竟人月神话写于1975年），用现代案例重新审视经典理论的生命力。软件工程的本质矛盾——变化与稳定、抽象与具体、短期与长期——从未消失，只是换上了新的外衣继续存在。理解原书思想的核心（如拥抱变化、设计弹性、组织适配）比具体技术建议更有持久价值。


## 第12章 干将莫邪

> 巧匠因为他的工具而出名。 ——谚语

编程人员所保留的个性化工具对软件项目来说是愚蠢的，主要原因是：

- 项目的关键问题是沟通，**个性化工具会妨碍沟通而非促进**
- 当机器和语言发生变化时，技术也会随之变化，**工具的生命周期实际是很短的**

所以选择开发和维护公共的通用工具的效率更高，但需要注意的是**除了通用工具，也需要关注到专业工具的需求**。所以项目经理需要考虑、计划、组织的工具到底有哪些？比如：

- 首先是计算机设施，需要硬件和使用安排策略；需要操作系统，明确提供服务的方式；需要语言，明确语言的使用方针
- 然后是实用程序、调试辅助程序、测试用例生成工具和处理文档的字处理系统等

!!! abstract "**#1 目标机器**"

机器支持可有效划分为**目标机器支持和辅助机器支持**，其中目标机器是软件所服务的对象即程序必须在该机器上进行最后测试。

**1. 目标机器的类型**

- **目标机器的特点与需求**
    - 团队开发的监督程序或系统核心软件需要专用目标机器
    - 需要配备操作员和系统编程人员来维护标准支持
    - 确保机器上的标准支持及时更新和可用
- **额外机器资源的配置**
    - 系统需要配置速度适中但资源充足的机器
    - 主要硬件需求：足够的内存容量（至少几兆字节）和在线存储（百兆字节级别），适合的终端设备（字符型终端速度需快于15字符/秒）
    - 大容量内存有助于进行功能测试后的进程覆盖和剪裁工作，提高生产率
- **调试设备的重要性**
    - 需要配备专门的调试机器或软件
    - 这些工具能在调试过程中自动计数和测量各类程序参数
    - 内存使用模式分析是重要的诊断措施，可查找程序中的异常行为或性能问题

**2. 进度安排**

**目标机器的时间稀缺问题**：当目标机器刚被研制、其第一个操作系统开发时，机器时间极其匮乏，**进度安排成为了开发过程中的主要问题**，目标机器的使用时间需求呈现特殊的增长曲线如下：

![](https://img.zhengyua.cn/blog/202502281025310.png)

- **OS/360开发中的实际经验**：
    - 团队拥有良好的System/360仿真器和辅助设施
    - 基于经验预先向制造商预定了机器使用时间
    - 初期遇到资源紧张问题：16个系统同时上线导致资源不足，且团队成员在同一时间开始调试各自组件，造成竞争状态

- **资源调度的改进措施**
    - 集中管理所有机器和磁带库资源
    - 组建专业团队进行操作
    - 采用批处理方式运行所有测试任务
    - 实际需求为4小时周转时间，团队实现了2.5小时周转（每天4次）
    - 使用1401辅助机器进行调度，跟踪上万个任务

- **从混乱到秩序的转变**：开发团队初期过度竞争资源，导致缓慢周转、相互指责和痛苦，后改为将机器时间分配成连续的块，连续时间块的优势在于：**虽然机器利用率可能略有降低，但生产率显著提高**；持续的精力集中减少了思考中断时间



!!! abstract "**#2 辅助机器和数据服务**"

**1. 仿真装置的关键价值**

- 对新产品开发，需要一个目标机器的逻辑仿真装置
- 仿真装置在新机器生产前提供辅助调试平台，即使新机器出现后，仿真装置仍能提供可靠的调试环境
- 尽管仿真不等于精确，**但在一段时间内提供稳定实现**，而新硬件可能不稳定

**2. 稳定性的重要性**

现代计算机硬件通常能够正常工作，程序员已习惯于此,所以程序员遇到运行不一致时，**会检查自己的代码而非怀疑平台**。而实际上新机器开发中的不稳定环境会带来严重问题，**不确定性最糟糕，剥夺了开发人员查找bug的动力**，比如出现问题时可能所有机器副本都需修改，且硬件失败通常是间歇性的，导致情况更加恶劣。稳定辅助平台上的仿真装置提供了远超预期的价值

**3. 编译器和汇编平台**

- 编译器和汇编软件需在可靠辅助平台上运行
- 在高级语言编程中，编译器可在辅助机器上完成目标代码的测试
- 这直接支持了开发，而不仅是稳定机器上的仿真结果

**4. 程序库管理系统**

OS/360开发中的重要辅助应用是程序库维护，**库被划分为不同访问规则的子库**：

- 开发库(playpen)：每个人有自己区域存放程序，无限制
- 系统集成子库：开发人员提交给集成经理审批
- 当前版本子库：广泛应用的稳定版本，不可更改除非修复重大缺陷

程序库管理中通常责任控制是程序副本由经理负责，独立授权变更，同时做到使发布进度正式化，实现开发库与发布正式分离。该技术实际上也能看作**是管理技术的一部分**，多个大型项目独立发展了类似技术，同样适用于文档管理，是不可或缺的技术。

**5. 编程工具**

- **尽管新调试技术出现，旧方法仍有必要**。项目初期就应指定工具操作和维护人员
- 需要内存转储、源文件编辑、快照转储等工具，实用程序同样必要：磁带走带、打印文件、更改目录等

**6. 文档系统**

- 最节省劳动力的工具是**计算机化文本编辑系统**
- 对于被认为"无用"的6英寸厚OS/360手册，作者提出两点反驳：
    1. OS/360文档规模虽大，**但可选择性阅读节省时间**
    2. OS/360文档比简短的编程系统特性文档更加可取
    3. 作者承认手册有改进空间，一些部分已经重写得更好

**7. 性能仿真装置**

- 建议开发性能仿真装置，尽早开始这项工作，**仔细倾听"它们表达的意见"**
- 应使用**自上而下设计方法**，同时实现性能仿真、逻辑仿真和产品


!!! abstract "**#3 高级语言和交互式编程**"

**1. 高级语言的前瞻性观点**

- 作者指出在10年前的OS/360开发中，未使用现在最重要的两种编程工具
- 这两种工具（高级语言和交互式编程）如今已证明其功效和适用性
- 作者确信只有懒散和惰性会妨碍它们的广泛应用，技术困难不再是借口

**2. 高级语言的核心优势**

- 使用高级语言的主要理由：提高生产率和调试速度
- 作者在第8章讨论过生产率问题，强调高级语言带来整体提升而非部分增加
- 调试改进的关键因素：
    - 更少的bug出现
    - 更容易查找bug
    - 避免了错误面前暴露所有级别的工作（减少语法和语义错误）
    - 编译器的诊断机制帮助找出错误
    - 容易插入调试快照
- 作者认为这些生产率和调试方面的优势是势不可挡的

**3. 对高级语言批评的反驳**

- 传统反对意见有三点：
    1. 无法完成所需功能
    2. 目标代码过于庞大
    3. 目标代码运行速度过慢
- 作者坚信这些反对不再存在，所有证据表明可以完成需要的功能，只是需要时间和精力
- 在空间方面，新的优化编译器令人满意且持续改进
- 在速度方面，优化编译器生成的代码比大多数程序员手写代码效率更高

**3. 系统编程的高级语言选择**

作者认为PL/I是当时唯一合理的系统编程语言选择，PL/I优势：

- 提供完整功能集
- 与操作系统环境相吻合
- 拥有各种类型的编译器（交互式、高速、诊断性强、优化程度高）

**4. 交互式编程的贡献**

- MIT的Multics项目对软件编程系统开发做出贡献，Multics与批处理系统概念上的主要区别：
    - 多个级别上数据和程序的共享与保护
    - 可延伸的库管理
    - 终端用户间协作的设施
- 作者认为在许多应用上批处理系统不会被交互式系统取代，但Multics小组在系统编程应用上取得了最具说服力的成功

**5. 交互式编程的实证评估**

- 当时缺乏明显证据证明交互式工具的强大效力
- **调试是系统编程中最慢和困难部分，慢的调试周转时间是瓶颈**，对此，交互式编程的逻辑合理性不容置疑
- 贝尔实验室John Harr的研究提供了数据支持，显示在系统软件开发中，交互式编程生产率至少是批处理的2倍

![](https://img.zhengyua.cn/blog/202502281058472.png)


**6. 交互式工具与高级语言的协同作用**

交互式工具的有效使用需要采用高级语言开发，高级语言使修改代码和选择性打印结果变得容易，**两者结合形成了一对强大的工具组合**。


??? note "以下是 LLM 补充的思考和看法"

    **对总结的补充思考与看法：**

    —— **工具哲学与团队协作的深层矛盾** ——

    作者强调标准化工具的价值，但现实中个性化工具往往是技术债的源头。现代开源的崛起（如GitHub统一了版本控制工具）印证了这一观点：**工具的标准化本质是建立团队共识语言的过程**。但需警惕另一种极端——过度追求工具统一可能压抑创新，例如某些前沿领域（如AI算法开发）依赖研究人员自建工具链。平衡点在于：**核心流程强制统一，创新领域允许个性化工具孵化，成熟后再纳入标准化体系**。

    —— **目标机器资源的隐喻** ——

    文中描述的“机器时间争夺战”在云原生时代有了新解：**弹性资源分配机制**。Kubernetes的自动扩缩容特性本质上是通过抽象化硬件资源，解决了物理机时代的零和博弈。但作者提出的“连续时间块”理念仍具启示——现代敏捷开发中“深度工作时段”（如Google的20%时间）与会议安排间的冲突，本质上仍是注意力资源的调度问题。

    —— **仿真装置的现代镜像** ——

    硬件仿真在物联网时代展现出新形态：数字孪生（Digital Twin）技术。它不仅模拟硬件行为，更通过实时数据镜像实现预测性调试。作者当年对“稳定性优先”的坚持，在自动驾驶系统开发中得到验证——Waymo的虚拟仿真测试里程远超真实路测，正是通过构建超现实仿真环境规避早期硬件的不确定性风险。

    —— **程序库管理的前瞻性** ——

    OS/360的库分层机制（开发库→集成库→发布库）正是GitFlow工作流的雏形。但现代实践更进一步：**基础设施即代码（IaC）**将硬件配置也纳入版本控制，例如Terraform的状态文件管理。而“文档即代码”运动（如用Markdown+Git管理文档）则完全实现了作者对计算机化文本系统的愿景。

    —— **高级语言的预言实现** ——

    作者对PL/I的推崇已被历史重构：C语言证明了系统编程可用高级语言实现，Rust则解决了内存安全与性能的终极矛盾。更有趣的是**DSL（领域特定语言）的兴起**：Kubernetes的YAML配置、SQLAlchemy的表达式语言，都是“高级语言思想”向垂直领域的渗透。这验证了作者的核心判断：**抽象层次的提升是不可逆的技术进化方向**。


    —— **交互式编程的范式革命** ——

    文中提到的调试效率问题，在Jupyter Notebook、REPL环境得到极致体现。但更具颠覆性的是**云IDE（如Gitpod/CodeSpaces）**，它将整个开发环境变成可版本控制的交互式沙箱。而ChatGPT驱动的Copilot类工具，正在将“人机交互”升级为“实时智能协作”，这可能是作者未能预见但会惊叹的交互式编程新维度。

    —— **被忽视的暗线：工具的心理契约** ——

    作者未明言但贯穿全章的是**工具对团队心智模式的重塑**。标准化工具强制建立共同思维框架（如Git约束了代码提交规范），而交互式环境培养即时反馈的思维习惯。现代开发者对“热重载”“实时预览”的依赖，本质是工具改变了人类对“开发-反馈”循环的速度阈值预期，这种认知惯性的力量可能比技术本身更深远。