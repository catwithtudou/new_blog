# 25.02《软件设计的哲学》阅读笔记


## 0. 前言


**1. 软件设计的缺失讨论**

- 过去80年软件开发更关注流程（如敏捷）、工具（如版本控制）和编程范式（如面向对象），但关于**如何设计高质量软件的核心问题**长期未被深入探讨

- 作者指出1971年David Parnas的模块分解论文仍是该领域重要参考，暗示软件设计方法论进展缓慢

**2. 核心问题：问题分解**

- 计算机科学最根本挑战是**将复杂问题拆分为可独立解决的模块**，但学术界鲜有系统化教学

- 当前教育更侧重编程语法（如循环语句）而非设计思维训练

**3. 程序员能力差异的根源**

- 优秀程序员与普通程序员的核心差异在于设计能力，而非天赋

- 作者通过斯坦福CS190课程实践"写作式教学法"：通过迭代开发→代码评审→重构改进的模式，帮助学生实践设计原则

**4. 本书的实践基础**

- 内容提炼自作者25万行代码的实战经验，涵盖操作系统、工具链、脚本语言等领域

- 设计原则强调哲学层面（如"消除错误的存在"），需通过具体编码实践理解

**5. 开放性态度**

- 作者声明本书非终极答案，鼓励读者结合自身经验辩证吸收



## 第1章 介绍


!!! note 关键结论

    软件设计是持续对抗复杂性的过程，优秀设计应使系统复杂度增速低于功能需求增速。

    开发者需像作家反复润色文稿一样，通过迭代重构逼近理想设计状态。


**1. 软件复杂性的本质**

**核心命题**：软件开发的最大障碍是**认知复杂性**。程序员受限于理解不断膨胀的系统复杂性，导致开发效率下降、错误率上升。

**复杂性来源**：

- 组件间隐式依赖
- 功能迭代导致的逻辑交织
- 多人协作带来的设计理念冲突

**2. 对抗复杂性的两种策略**

| **策略**                | **具体方法**                                                                 | **关键示例**                          |
|-------------------------|-----------------------------------------------------------------------------|---------------------------------------|
| **消除复杂性**          | 通过简化代码逻辑降低认知负荷                                                | 统一命名规范，消除冗余条件分支        |
| **封装复杂性**          | 模块化设计实现关注点分离                                                    | 类/服务隔离实现，隐藏内部实现细节     |

**3. 软件开发模型对比**

- **瀑布模型缺陷**：

    - 预设完整设计在复杂系统中不可行
    - 后期修改成本指数级增长（如桥梁中途改结构）

- **增量开发优势**：

    - 允许持续重构（如敏捷开发）
    - 每个迭代周期暴露设计缺陷
    - 早期经验优化后续功能实现

**4. 软件设计的持续性特征**

- **设计即重构**：初始设计必然存在缺陷，需通过：

    - 代码审查（他人视角发现设计问题）
    - 危险信号识别（如过度嵌套/重复模式）
    - 定期投入10-20%时间进行设计优化

- **设计平衡观**：

    - 警惕过度设计（如"Taking it too far"章节）
    - 类深度 vs 接口简洁的权衡

**5. 实践建议**

- **学习路径**：

    - 通过真实代码审查理解设计原则
    - 建立个人"危险信号"清单（如过长嵌套/模糊命名）

- **技术普适性**：

    - 虽然示例使用Java/C++，原则适用于C函数/微服务等场景
    - 核心思想：**通过抽象层级控制认知负载**



## 第2章 复杂性的本质


!!! note 关键结论


    - **复杂性定律**：软件维护成本 = f(依赖性×模糊性)
    - **设计者的使命**：通过降低模块耦合度、提升信息可见性，使系统复杂度增速 << 功能需求增速
    - **终极检验标准**：新成员能否在无文档情况下，凭直觉正确修改系统核心功能？

    （第3章将具体探讨如何在日常开发中实践"零容忍"原则对抗复杂性）




**1. 复杂性的本质定义**

- **核心定义**：任何导致系统**难以理解和修改**的软件结构特征
    - **关键视角**：以开发者**完成具体任务时的体验**为衡量标准，而非系统规模
    - **数学表达**：系统总复杂度 = Σ（各模块复杂度 × 开发者投入该模块的时间占比）
    - **黄金法则**：若他人认为你的代码复杂，则它就是复杂的（开发者的主观感受具有决定性）

**2. 复杂性三大症状**

| **症状**           | **表现特征**                                                                 | **典型案例**                                                                 |
|--------------------|-----------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| **变更放大**       | 简单修改需要调整多处代码                                                        | 早期网站每个页面硬编码背景色，修改需遍历所有文件（图2.1a → 2.1b的改进）         |
| **认知负荷**       | 完成任务需掌握大量隐式知识                                                      | C语言函数要求调用者手动释放内存，开发者必须记住此规则否则引发内存泄漏           |
| **未知的未知**     | 无法预知修改会对哪些模块产生影响                                                   | 修改中心背景色变量后，未发现某些页面使用其衍生色（图2.1c的强调色未同步更新）     |

>
> **危害排序**：未知的未知 > 认知负荷 > 变更放大
>
> **设计目标**：通过"显而易见性(Obviousness)"对抗复杂性（第18章具体方法）

**3. 复杂性的根本成因**

**Ⅰ 依赖性(Dependencies)**

- **定义**：代码修改必须联动调整其他相关部分
- **典型场景**：
    - **显性依赖**：函数参数变更导致所有调用点需修改
    - **隐性依赖**：多模块共享全局状态（如旧版网站背景色分散定义）
- **管理原则**：
    - **隔离高频修改点**（如现代网站集中管理颜色变量）
    - **通过编译器强制**（如变量重命名触发编译错误）

**Ⅱ 模糊性(Obscurity)**


- **定义**：关键信息未被清晰传达
- **表现形式**：
    - **命名不当**：`time`变量未说明是秒/毫秒
    - **文档缺失**：错误码对应含义未记录
    - **隐性约定**：消息表与状态声明无显式关联
- **根治方法**：
    - **自解释设计** > 补充文档（第13章详述）
    - **保持一致性**（如禁用多用途变量名）

**4. 复杂性的递增特性**

- **累积机制**：每个看似无害的微小设计缺陷（如一个模糊命名）叠加产生指数级维护成本
- **反直觉现象**：
    - 单一依赖/模糊性问题危害不大
    - 但千级规模代码需面对**网状交叉影响**
- **防御策略**：
    - **零容忍哲学**：每个提交都力求简化设计（第3章展开）
    - **持续重构**：像偿还技术债务一样修复微小缺陷


## 第3章 工作代码是不够的


!!! note 关键结论

    **好的设计需要持续投资**，但它最终会带来回报，而且比想象中更快。关键是：

    - 保持一致地应用战略方法
    - 将投资视为今天要做的事，而非推迟到明天
    - 每个工程师都持续进行小规模的设计改进
    - 避免"滑坡效应"——一旦开始推迟设计改进，很容易变成永久性延迟

    **核心启示**：虽然战术编程可能带来短期收益，但从长远来看，战略编程是构建可持续、高质量软件系统的唯一途径。

**1. 战术编程 vs 战略编程**

**战术编程**和**战略编程**是两种截然不同的软件开发思维方式，它们的区别在于：

| 战术编程 | 战略编程 |
|---------|---------|
| 关注当下任务的快速完成 | 关注系统的长期结构和质量 |
| 短视的、功能驱动的 | 投资思维、设计驱动的 |
| 渐进式增加复杂性 | 持续性改进系统设计 |
| 优先考虑短期速度 | 优先考虑长期可维护性 |
| 倾向于避免重构 | 主动进行设计改进和重构 |

**2. 战术编程的问题**

**战术编程的核心问题是短视**。当开发者只关注快速完成当前任务时，会导致：

- 复杂性逐渐累积，没有人愿意花时间清理
- 代码质量持续下降，系统逐渐变得难以维护
- 形成"补丁上加补丁"的恶性循环
- 长期来看，开发速度显著降低

在一些组织中，存在"**战术龙卷风**"式的开发者——他们能极快地开发功能，但留下的代码质量差，需要其他开发者花费大量时间清理。

**3. 战略编程的本质**

战略编程的核心理念是：**能工作的代码是不够的**。开发者需要：

- 将系统的长期结构作为首要考虑因素
- 愿意投入时间改进设计，即使短期内会放慢速度
- 采取主动投资（找到简单设计、预见未来变化）和被动投资（发现问题时修复）
- **建议投入总开发时间的10-20%用于设计投资**

**4. 投资回报曲线**

![](https://img.zhengyua.cn/blog/202503110959991.png)

- **短期**：战术方法看似更快，战略方法因投资设计而略慢
- **中期**：战术方法积累的复杂性开始减缓开发速度，战略方法因良好设计开始加速
- **长期**：战略方法明显更快，且投资变为"免费"——过去投资节省的时间足以覆盖未来投资

**5. 创业公司的挑战与选择**

创业公司面临更大的交付压力，但仍有两种截然不同的路径：

1. **Facebook模式**："快速行动并打破常规"的战术方法
   - 短期交付速度较快
   - 代码库逐渐变得混乱难以维护
   - 最终不得不改变方向："以坚实的基础架构快速移动"

2. **Google/VMware模式**：战略性方法
   - 注重高质量代码和良好设计
   - 构建可靠的复杂系统
   - 吸引顶尖技术人才的强大技术文化


## 第4章 模块应该是深的

!!! note 关键结论

    通过分离接口和实现，我们可以将实现的复杂性从系统的其余部分隐藏起来。设计类和模块的关键是**使它们深入**，为常见用例提供简单接口，同时提供重要功能。这最大限度地隐藏了复杂性。

    **核心思想**：模块设计应该追求"深度"——用简单接口暴露强大功能，而非"宽度"——大量功能简单但接口复杂的浅层模块。

**1. 模块化设计的本质**

模块化设计是管理软件复杂性的关键技术，它允许开发人员**在任何时刻只需面对整体复杂性的一小部分**。在软件系统中，模块可以是类、子系统或服务等多种形式。

**理想的模块化**：每个模块完全独立，开发者可以在不了解其他模块的情况下工作。但这个理想无法完全实现，因为模块之间必须协同工作，这就产生了依赖关系。

**模块化设计的目标**：最小化模块之间的依赖性。

**2. 模块的接口与实现**

每个模块由两个关键部分组成：

| 接口 | 实现 |
|-----|-----|
| 其他模块开发者需要了解的内容 | 实现接口承诺的代码 |
| 描述"做什么"，而非"怎么做" | 实现具体功能的内部细节 |
| 包括形式化元素(函数签名)和非形式化元素(行为、约束) | 对模块用户隐藏 |

**良好接口的价值**：它准确指示开发人员使用模块所需了解的内容，帮助消除"未知的未知"问题。

**3. 抽象的概念**

**抽象**是实体的简化视图，省略了不重要的细节。在模块化编程中，每个模块通过其接口提供抽象。

抽象可能出现的两类错误：

1. **包含了不重要的细节**：使抽象比必要的更复杂，增加认知负担
2. **省略了重要的细节**：导致模糊性，用户无法正确使用抽象

**设计抽象的关键**是识别什么是重要的，并寻找能将重要信息量最小化的设计。

**4. 深度模块与浅层模块**

**4.1. 深度模块**

**深度模块**提供强大功能但拥有简单接口，它们是好的抽象，因为只有很小一部分内部复杂性对用户可见。

深度模块可以用矩形来可视化：

- 矩形面积 = 模块实现的功能
- 顶部边缘长度 = 接口复杂性
- 最好的模块是"深的"矩形：面积大但顶边短

**深度模块的优点**：

- 最小化模块给系统其它部分带来的复杂性
- 如果修改不改变接口，则不会影响其他模块

**深度模块的例子**：

- **Unix文件I/O**：仅有5个基本系统调用（open, read, write, lseek, close），但实现了数十万行代码处理的复杂功能
- **垃圾收集器**：几乎没有接口，在后台工作，但隐藏了复杂的内存回收机制

**4.2 浅层模块**

**浅层模块**的接口相对于其提供的功能而言过于复杂。

**浅层模块的问题**：

- 学习和使用接口的成本抵消了它提供的收益
- 没有显著帮助管理复杂性

**极端例子**：只有一行代码的方法`addNullValueForAttribute`，它增加了接口复杂性但没有提供任何抽象价值。

**5. Classitis**

当前编程中常见的误区是"类应该小"。这种思维导致了 **Classitis**：错误地认为"类是好的，所以类越多越好"。

**Classitis 的问题**：

- 小类单独可能简单，但增加了系统总体复杂性
- 需要大量小类，每个都有自己的接口
- 接口累积创造了系统级的巨大复杂性
- 导致冗长的编程风格

**示例对比**：

- **Java I/O**：打开一个文件读取序列化对象需要创建三个不同对象（FileInputStream, BufferedInputStream, ObjectInputStream）
- **Unix I/O**：设计者使常见情况简单，默认提供顺序I/O，而随机访问作为可选功能

**6. 关键设计原则**

**接口设计的重要原则**：**应该设计接口以使常见情况尽可能简单**。例如，若大多数用户需要缓冲，则应默认提供缓冲。

如果接口有许多功能，但大多数开发者只需了解其中几个，那么接口的**有效复杂性**就是常用功能的复杂性。

## 第5章 信息隐藏（和泄漏）


!!! note "关键结论"

    **信息隐藏与深层模块紧密相关**：
    - 隐藏大量信息的模块通常功能丰富但接口简单，因此更深入
    - 不隐藏信息的模块要么功能有限，要么接口复杂，通常是浅层的

    系统分解的最佳方法是：
    - 避免受运行时操作顺序影响（时间分解）
    - 思考应用程序任务所需的不同知识
    - 设计每个模块来封装这些知识中的一个或几个
    - 这将产生干净、简单且深入的模块设计

    **核心思想**：好的模块设计应该围绕知识封装而非时间顺序，通过隐藏实现细节来降低系统整体复杂性。


**1. 信息隐藏的本质**

**信息隐藏**是实现深层模块的最重要技术，由 David Parnas 首次提出。其核心思想是：**每个模块应封装代表设计决策的知识，这些知识嵌入在模块实现中但不出现在接口中**。

模块中隐藏的信息通常包括：

- 实现特定机制的数据结构和算法
- 较低级别的技术细节
- 较高级别的抽象概念和假设

**2. 信息隐藏的双重价值**

信息隐藏通过两种方式降低复杂性：

| 价值 | 描述 |
|------|------|
| **简化接口** | 提供更简单、更抽象的功能视图，隐藏细节，减少使用模块的开发人员的认知负担 |
| **促进系统演化** | 由于封装了知识，对相关设计决策的更改只会影响单个模块，而不会波及整个系统 |

**3. 信息泄漏与其危害**

**信息泄漏**是信息隐藏的反面，当一个设计决策反映在多个模块中时发生。这创建了模块间依赖关系：对该设计决策的任何更改都需要修改所有涉及模块。

信息可以通过两种方式泄漏：

- **通过接口泄漏**：设计信息直接出现在接口中
- **后门泄漏**：即使不在接口中，多个模块都依赖同一知识（如文件格式）

**信息泄漏是软件设计中最重要的危险信号之一**。应当培养对信息泄漏的高度敏感性，发现后应考虑重组类结构。

**4. 时间分解：信息泄漏的常见原因**

**时间分解**是一种设计风格，系统结构对应于操作将发生的时间顺序。这常导致信息泄漏，因为：

- 相同知识可能在不同时间点使用
- 将相关功能分散到多个类中

🚩 **关键原则**：在设计模块时，应**关注执行每个任务所需的知识，而非任务发生的顺序**。

**5. 实例分析：HTTP服务器**

**5.1 问题1：太多浅层类**

一些学生团队犯的错误是将HTTP请求处理分成两个类：一个读取请求，一个解析请求。这是时间分解的例子，导致了信息泄漏，因为：

- 读取HTTP请求需要解析大部分消息
- 两个类都需要了解HTTP请求的结构
- 解析代码在两个类中重复

**解决方案**：将相关功能合并到一个类中，提供更好的信息隐藏和更简单的接口。

**5.2 改进信息隐藏的一般策略：适当增大类的规模**

1. 将相关功能集中到一起
2. 提高接口级别（用一个高级方法替代多个低级方法）
3. 结果：接口更简单，类更深入

**5.3 问题2：HTTP参数处理**

大多数学生项目在参数处理方面有两个好的设计决策：

1. 隐藏参数来源（请求行vs请求体）的区别
2. 隐藏URL编码的知识（自动解码）

但他们使用了太浅的接口：

```java
public Map<String, String> getParams() {
    return this.params;
}
```

这种设计的问题：

- 暴露内部表示
- 任何实现变更都会影响接口
- 增加调用者工作量
- 调用者可能无意修改内部状态

**更好的接口设计**：

```java
public String getParameter(String name) { ... }
public int getIntParameter(String name) { ... }
```

这种设计：

- 隐藏内部实现
- 提供类型转换功能
- 简化调用

**5.4 问题3：HTTP响应中的默认值**

一些团队要求调用者显式指定HTTP响应的版本和时间，而这些信息通常可以自动从请求推断或系统获取。

**改进原则**：

- **接口应设计为使常见情况尽可能简单**
- 默认值是部分信息隐藏的例子：通常情况下用户不需要知道这些细节
- 类应当"自动做正确的事"，无需显式要求

**6. 类内部的信息隐藏**

信息隐藏也适用于类内部：

- 设计私有方法来封装和隐藏信息
- 尽量减少实例变量的使用范围
- 降低类内部的依赖关系和复杂性

**7. 信息隐藏的界限**

信息隐藏并非放之四海而皆准：**如果模块外部需要某信息，就不应隐藏它**。

作为设计者，目标应该是：

- **尽量减少模块外部需要的信息量**
- **优先考虑自动调整而非暴露配置参数**
- **正确识别哪些信息确实需要公开**

