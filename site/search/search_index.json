{"config":{"lang":["en","zh"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"algorithms/","title":"README","text":"<p>\u7a0b\u5e8f\u5458\u7684\u57fa\u672c\u529f</p>"},{"location":"algorithms/books/","title":"Books","text":"<p>Books About Algorithm</p> <p>Recently Reading:</p> <ul> <li> <p> \u300a\u4ee3\u7801\u968f\u60f3\u5f55\u300b\uff08202402\uff5e\uff09</p> </li> <li> <p> \u300a\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5\u4e4b\u7f8e\u300b</p> </li> </ul>"},{"location":"algorithms/books/code_caprice/","title":"\u300a\u4ee3\u7801\u968f\u60f3\u5f55\u300b","text":"<p>href: https://programmercarl.com/</p> <ul> <li> \u7b97\u6cd5\u6027\u80fd\u5206\u6790</li> <li> \u6570\u7ec4</li> <li> \u94fe\u8868</li> <li> \u54c8\u5e0c\u8868</li> <li> \u5b57\u7b26\u4e32</li> <li> \u53cc\u6307\u9488\u6cd5</li> <li> \u6808\u4e0e\u961f\u5217</li> <li> \u4e8c\u53c9\u6811</li> <li> \u56de\u6eaf\u7b97\u6cd5</li> <li> \u8d2a\u5fc3\u7b97\u6cd5</li> <li> \u52a8\u6001\u89c4\u5212</li> <li> \u5355\u8c03\u6808</li> <li> \u56fe\u8bba</li> </ul>"},{"location":"algorithms/books/code_caprice/array/01basic/","title":"\u6570\u7ec4\u7406\u8bba\u57fa\u7840","text":"<p>1. \u6570\u7ec4\u7684\u5b9a\u4e49&amp;\u7279\u70b9</p> <ul> <li>\u6570\u7ec4\u662f\u5b58\u653e\u5728\u8fde\u7eed\u5185\u5b58\u7a7a\u95f4\u4e0a\u7684\u76f8\u540c\u7c7b\u578b\u6570\u636e\u7684\u96c6\u5408</li> <li>\u6570\u7ec4\u53ef\u4ee5\u65b9\u4fbf\u7684\u901a\u8fc7\u4e0b\u6807\u7d22\u5f15\u7684\u65b9\u5f0f\u83b7\u53d6\u5230\u4e0b\u6807\u4e0b\u5bf9\u5e94\u7684\u6570\u636e</li> </ul> <p>2. \u6570\u7ec4\u7684\u7279\u70b9</p> <p></p> <ul> <li>\u6570\u7ec4\u4e0b\u6807\u90fd\u662f\u4ece0\u5f00\u59cb\u7684</li> <li>\u6570\u7ec4\u5185\u5b58\u7a7a\u95f4\u7684\u5730\u5740\u662f\u8fde\u7eed\u7684 <ul> <li>\u6240\u4ee5\u5728\u5bf9\u6570\u7ec4\u5143\u7d20\u8fdb\u884c\u64cd\u4f5c\u65f6\uff0c\u80af\u5b9a\u4f1a\u8003\u8651\u5230\u79fb\u52a8\u5176\u4ed6\u5143\u7d20\u7684\u5730\u5740</li> <li>\u4e8c\u7ef4\u6570\u7ec4\u7684\u5185\u5b58\u7a7a\u95f4\u662f\u5426\u8fde\u7eed\uff0c\u53d6\u51b3\u4e8e\u4e0d\u540c\u7684\u7f16\u7a0b\u8bed\u8a00\u5bf9\u5185\u5b58\u7ba1\u7406\u7684\u5b9e\u73b0</li> </ul> </li> <li>\u6570\u7ec4\u7684\u5143\u7d20\u4e0d\u80fd\u5220\u7684\u800c\u53ea\u80fd\u8986\u76d6</li> </ul>"},{"location":"algorithms/books/code_caprice/array/02array_algorithms/","title":"\u6570\u7ec4\u7b97\u6cd5","text":""},{"location":"algorithms/books/code_caprice/array/02array_algorithms/#1-\u4e8c\u5206\u67e5\u627e","title":"1. \u4e8c\u5206\u67e5\u627e","text":"<p>\u6838\u5fc3\u70b9</p> <ul> <li>\u6709\u5e8f\u6570\u7ec4</li> <li>\u5c06\u76ee\u6807\u503c\u4e0e\u6570\u7ec4\u4e2d\u95f4\u5143\u7d20\u8fdb\u884c\u6bd4\u8f83\uff0c\u4ece\u800c\u6392\u9664\u6389\u4e00\u534a\u7684\u5143\u7d20\uff0c\u5982\u6b64\u5faa\u73af\uff0c\u76f4\u5230\u627e\u5230\u76ee\u6807\u503c\u6216\u786e\u5b9a\u76ee\u6807\u503c\u4e0d\u5b58\u5728</li> <li>\u901a\u5e38\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\\(O(logn)\\)</li> </ul> <p>\u5176\u4e2d\u9700\u8981\u6ce8\u610f:</p> <ul> <li>\u533a\u95f4\u8303\u56f4\u51b3\u5b9a\u4e86\u8fb9\u754c\uff08\u5305\u542b\u8d77\u59cb\u4f4d\u7f6e\uff09\u7684\u503c\uff0c\u53ef\u901a\u8fc7\u6784\u9020\u7b80\u5355\u7684\u6709\u5e8f\u6570\u7ec4\u6765\u6f14\u7b97\u8fdb\u884c\u7406\u89e3</li> </ul>"},{"location":"algorithms/books/code_caprice/array/02array_algorithms/#11-\u7b97\u6cd5\u4e8c\u5206\u6cd5","title":"1.1 \u7b97\u6cd5:\u4e8c\u5206\u6cd5","text":"<ol> <li>\u5de6\u95ed\u53f3\u95ed [left, right]</li> </ol> Go<pre><code>func search(nums []int, target int) int {\n    high := len(nums)-1\n    low := 0\n    for low &lt;= high {\n        mid := low + (high-low)/2\n        if nums[mid] == target {\n            return mid\n        } else if nums[mid] &gt; target {\n            high = mid-1\n        } else {\n            low = mid+1\n        }\n    }\n    return -1\n}\n</code></pre> <ol> <li>\u5de6\u95ed\u53f3\u5f00 [left, right)</li> </ol> Go<pre><code>func search(nums []int, target int) int {\n    left, right := 0, len(nums)\n    for left &lt; right {\n        mid := left + (right-left)/2\n        if nums[mid] &gt; target {\n            right = mid\n        } else if nums[mid] &lt; target {\n            left = mid + 1\n        } else {\n            return mid\n        }\n    }\n\n    return -1\n}\n</code></pre>"},{"location":"algorithms/books/code_caprice/array/02array_algorithms/#12-\u76f8\u5173\u9898\u76ee","title":"1.2 \u76f8\u5173\u9898\u76ee","text":"<ul> <li> 704\u4e8c\u5206\u67e5\u627e</li> <li> 35.\u641c\u7d22\u63d2\u5165\u4f4d\u7f6e </li> <li> 34.\u5728\u6392\u5e8f\u6570\u7ec4\u4e2d\u67e5\u627e\u5143\u7d20\u7684\u7b2c\u4e00\u4e2a\u548c\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e </li> <li> 69.x \u7684\u5e73\u65b9\u6839 </li> <li> 367.\u6709\u6548\u7684\u5b8c\u5168\u5e73\u65b9\u6570</li> </ul>"},{"location":"algorithms/books/code_caprice/array/02array_algorithms/#2-\u79fb\u9664\u5143\u7d20","title":"2. \u79fb\u9664\u5143\u7d20","text":"<p>\u5bf9\u5e94 LeetCode \u9898\u76ee\uff1a </p> <p>Note</p> <p>\u6570\u7ec4\u7684\u5143\u7d20\u5728\u5185\u5b58\u5730\u5740\u4e2d\u662f\u8fde\u7eed\u7684\uff0c\u4e0d\u80fd\u5355\u72ec\u5220\u9664\u6570\u7ec4\u4e2d\u7684\u67d0\u4e2a\u5143\u7d20\uff0c\u53ea\u80fd\u8986\u76d6\u3002</p> <p>\u82e5\u91c7\u53d6\u66b4\u529b\u89e3\u6cd5\uff0c\u5219\u7c7b\u4f3c\u4e8e\u5192\u6ce1\u6392\u5e8f\u8fdb\u884c\u4e24\u5c42\u904d\u5386\uff0c\u4e0b\u9762\u91cd\u70b9\u8bf4\u660e\u53cc\u6307\u9488\u6cd5\u3002</p>"},{"location":"algorithms/books/code_caprice/array/02array_algorithms/#21-\u7b97\u6cd5\u53cc\u6307\u9488\u6cd5","title":"2.1 \u7b97\u6cd5:\u53cc\u6307\u9488\u6cd5","text":"<p>\u53cc\u6307\u9488\u6cd5\uff08\u5feb\u6162\u6307\u9488\u6cd5\uff09\uff1a </p> <ul> <li>\u901a\u8fc7\u4e00\u4e2a\u5feb\u6307\u9488\u548c\u6162\u6307\u9488\u5728\u4e00\u4e2afor\u5faa\u73af\u4e0b\u5b8c\u6210\u4e24\u4e2afor\u5faa\u73af\u7684\u5de5\u4f5c</li> </ul> <p>\u5b9a\u4e49\u5feb\u6162\u6307\u9488\uff1a</p> <ul> <li>\u5feb\u6307\u9488\uff1a\u5bfb\u627e\u65b0\u6570\u7ec4\u7684\u5143\u7d20\uff0c\u65b0\u6570\u7ec4\u5c31\u662f\u4e0d\u542b\u6709\u76ee\u6807\u5143\u7d20\u7684\u6570\u7ec4 </li> <li>\u6162\u6307\u9488\uff1a\u6307\u5411\u66f4\u65b0\u65b0\u6570\u7ec4\u4e0b\u6807\u7684\u4f4d\u7f6e</li> </ul> <p>\u6b64\u601d\u8def\u4e0d\u4ec5\u5e94\u7528\u5728\u6570\u7ec4\u4e2d\uff0c\u5728\u5176\u4ed6\u5982\u94fe\u8868\u3001\u5b57\u7b26\u4e32\u7b49\u90fd\u6709\u76f8\u5e94\u5e94\u7528\u3002</p> <p>\u4e0b\u9762\u4e24\u4e2a\u89e3\u6cd5\u5747\u53ef\u6ee1\u8db3\u9898\u610f\uff0c\u540e\u8005\u7684\u4f18\u70b9\u5728\u4e8e\u786e\u4fdd\u79fb\u52a8\u7684\u6700\u5c0f\u6b21\u6570</p> <ul> <li>\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\\(O(n)\\)</li> <li>\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a\\(O(1)\\)</li> </ul> Go<pre><code>func removeElement(nums []int, val int) int {\n    slow := 0\n    for fast := 0; fast &lt; len(nums); fast++ {\n        if val != nums[fast] {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return slow\n}\n</code></pre> Go<pre><code>func removeElement(nums []int, val int) int {\n    leftIdx, rightIdx := 0, len(nums)-1\n    for leftIdx &lt;= rightIdx {\n\n        for leftIdx &lt;= rightIdx &amp;&amp; nums[leftIdx] != val {\n            leftIdx++\n        }\n\n        for leftIdx &lt;= rightIdx &amp;&amp; nums[rightIdx] == val {\n            rightIdx--\n        }\n\n        if leftIdx &lt; rightIdx {\n            nums[leftIdx] = nums[rightIdx]\n            leftIdx++\n            rightIdx--\n        }\n    }\n\n    return leftIdx\n}\n</code></pre>"},{"location":"algorithms/books/code_caprice/array/02array_algorithms/#22-\u76f8\u5173\u9898\u76ee","title":"2.2 \u76f8\u5173\u9898\u76ee","text":"<ul> <li> 27.\u79fb\u9664\u5143\u7d20</li> <li> 26.\u5220\u9664\u6392\u5e8f\u6570\u7ec4\u4e2d\u7684\u91cd\u590d\u9879</li> <li> 283.\u79fb\u52a8\u96f6</li> <li> 844.\u6bd4\u8f83\u542b\u9000\u683c\u7684\u5b57\u7b26\u4e32</li> <li> 977.\u6709\u5e8f\u6570\u7ec4\u7684\u5e73\u65b9</li> </ul>"},{"location":"algorithms/books/code_caprice/array/02array_algorithms/#3\u957f\u5ea6\u6700\u5c0f\u7684\u5b50\u6570\u7ec4","title":"3.\u957f\u5ea6\u6700\u5c0f\u7684\u5b50\u6570\u7ec4","text":"<p>\u5bf9\u5e94 LeetCode \u9898\u76ee\uff1a</p> <p></p> <p>Note</p> <p>\u6d89\u53ca\u5230\u8fde\u7eed\u5b50\u6570\u7ec4\u7684\u5904\u7406\uff0c\u53ef\u8003\u8651\u4f7f\u7528\u6ed1\u52a8\u7a97\u53e3\u7684\u7b97\u6cd5\u601d\u60f3\u6765\u89e3\u51b3</p> <p>\u82e5\u91c7\u53d6\u66b4\u529b\u89e3\u6cd5\uff0c\u5219\u662f\u901a\u8fc7\u4e24\u5c42\u5faa\u73af\u4e0d\u65ad\u5bfb\u627e\u7b26\u5408\u6761\u4ef6\u7684\u5b50\u5e8f\u5217\uff0c\u4e0b\u9762\u91cd\u70b9\u8bf4\u660e\u6ed1\u52a8\u7a97\u53e3\u89e3\u6cd5\u3002</p>"},{"location":"algorithms/books/code_caprice/array/02array_algorithms/#31-\u7b97\u6cd5\u6ed1\u52a8\u7a97\u53e3","title":"3.1 \u7b97\u6cd5:\u6ed1\u52a8\u7a97\u53e3","text":"<p>\u6ed1\u52a8\u7a97\u53e3\u7684\u4e3b\u8981\u601d\u60f3\uff1a</p> <ul> <li>\u4e0d\u65ad\u7684\u8c03\u8282\u5b50\u5e8f\u5217\u7684\u8d77\u59cb\u4f4d\u7f6e\u548c\u7ec8\u6b62\u4f4d\u7f6e\uff0c\u4ece\u800c\u5f97\u51fa\u9884\u671f\u7ed3\u679c</li> </ul> <p>\u6ed1\u52a8\u7a97\u53e3\u7684\u5b9e\u73b0\u901a\u5e38\u9700\u8981\u786e\u8ba4\u5982\u4e0b\u4e09\u70b9\uff1a</p> <ul> <li>\u7a97\u53e3\u5185\u662f\u4ec0\u4e48\uff1f <ul> <li>\u6ee1\u8db3\u5176\u548c\u2265s\u7684\u957f\u5ea6\u6700\u5c0f\u7684\u8fde\u7eed\u5b50\u6570\u7ec4     </li> </ul> </li> <li>\u5982\u4f55\u79fb\u52a8\u7a97\u53e3\u7684\u8d77\u59cb\u4f4d\u7f6e\uff1f <ul> <li>\u82e5\u5f53\u524d\u7a97\u53e3\u7684\u503c\u5927\u4e8es\u5219\u7a97\u53e3\u9700\u8981\u5411\u524d\u79fb\u52a8\u4e86</li> </ul> </li> <li>\u5982\u4f55\u79fb\u52a8\u7a97\u53e3\u7684\u7ed3\u675f\u4f4d\u7f6e\uff1f<ul> <li>\u7a97\u53e3\u7684\u7ed3\u675f\u4f4d\u7f6e\u5c31\u662f\u904d\u5386\u6570\u7ec4\u7684\u6307\u9488</li> </ul> </li> </ul> <p>\u5177\u4f53\u5b9e\u73b0\u4ee3\u7801\u5982\u4e0b\uff1a \u65f6\u95f4\u590d\u6742\u5ea6\uff1a\\(O(n)\\) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a\\(O(1)\\)</p> Go<pre><code>func minSubArrayLen(target int, nums []int) int {\n    start, end := 0, 0\n    result := len(nums) + 1\n    cur := 0\n    for ; end &lt; len(nums); end++ {\n        cur += nums[end]\n        for ; cur &gt;= target; start++ {\n            result = min(result, end-start+1)\n            cur -= nums[start]\n        }\n    }\n\n    if result == len(nums)+1 {\n        return 0\n    }\n    return result\n}\n</code></pre>"},{"location":"algorithms/books/code_caprice/array/02array_algorithms/#32-\u76f8\u5173\u9898\u76ee","title":"3.2 \u76f8\u5173\u9898\u76ee","text":"<ul> <li> 209.\u957f\u5ea6\u6700\u5c0f\u7684\u5b50\u6570\u7ec4</li> <li> 904.\u6c34\u679c\u6210\u7bee</li> <li> 76.\u6700\u5c0f\u8986\u76d6\u5b50\u4e32</li> </ul>"},{"location":"algorithms/books/code_caprice/array/02array_algorithms/#4-\u87ba\u65cb\u77e9\u9635ii","title":"4. \u87ba\u65cb\u77e9\u9635II","text":"<p>\u5bf9\u5e94 LeetCode \u9898\u76ee\uff1a</p> <p></p> <p>Note</p> <p>\u6b64\u9898\u91cd\u8981\u7684\u4e0d\u662f\u7b97\u6cd5\uff0c\u800c\u662f\u8003\u5bdf\u6a21\u62df\u7684\u8fc7\u7a0b</p>"},{"location":"algorithms/books/code_caprice/array/02array_algorithms/#41-\u7b97\u6cd5\u6a21\u62df\u8fc7\u7a0b","title":"4.1 \u7b97\u6cd5:\u6a21\u62df\u8fc7\u7a0b","text":"<p>\u5728\u4e0a\u9762\u63d0\u5230\u4e8c\u5206\u6cd5\u7684\u65f6\u5019\u5c31\u63d0\u5230\uff0c\u5982\u679c\u8981\u5199\u51fa\u6b63\u786e\u7684\u4e8c\u5206\u6cd5\u4e00\u5b9a\u8981\u575a\u6301\u5faa\u73af\u4e0d\u53d8\u91cf\u539f\u5219\u3002</p> <p>\u800c\u6c42\u89e3\u6b64\u9898\u4f9d\u7136\u662f\u8981\u575a\u6301\u5faa\u73af\u4e0d\u53d8\u91cf\u539f\u5219\uff0c\u6a21\u62df\u987a\u65f6\u9488\u753b\u77e9\u9635\u7684\u8fc7\u7a0b:</p> <ul> <li>\u586b\u5145\u4e0a\u884c\u4ece\u5de6\u5230\u53f3 </li> <li>\u586b\u5145\u53f3\u5217\u4ece\u4e0a\u5230\u4e0b </li> <li>\u586b\u5145\u4e0b\u884c\u4ece\u53f3\u5230\u5de6 </li> <li>\u586b\u5145\u5de6\u5217\u4ece\u4e0b\u5230\u4e0a</li> </ul> <p>\u8fd9\u91cc\u6211\u4eec\u5c31\u9700\u8981\u4fdd\u6301\u5faa\u73af\u4e0d\u53d8\u91cf\uff0c\u4fdd\u6301\u6bcf\u6761\u8fb9\u5de6\u95ed\u53f3\u5f00\u7684\u539f\u5219\uff0c\u5177\u4f53\u4ee3\u7801\u5982\u4e0b\uff1a</p> <p>\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\\(O(n^2)\\)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a\\(O(1)\\)</p> Go<pre><code>func generateMatrix(n int) [][]int {\n    result := make([][]int, n)\n    for i, _ := range result {\n        result[i] = make([]int, n)\n    }\n    startX, startY := 0, 0\n    mid := n / 2\n    count, offset := 1, 1\n    for loop := n / 2; loop &gt; 0; loop-- {\n        i, j := startX, startY\n\n        for j = startY; j &lt; n-offset; j++ {\n            result[startX][j] = count\n            count++\n        }\n        for i = startX; i &lt; n-offset; i++ {\n            result[i][j] = count\n            count++\n        }\n        for ; j &gt; startY; j-- {\n            result[i][j] = count\n            count++\n        }\n        for ; i &gt; startX; i-- {\n            result[i][j] = count\n            count++\n        }\n\n        startX++\n        startY++\n        offset++\n    }\n\n    if n%2 &gt; 0 {\n        result[mid][mid] = count\n    }\n    return result\n}\n</code></pre> Rust<pre><code>impl Solution {\n    pub fn generate_matrix(n: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n        let mut result = vec![vec![0; n as usize]; n as usize];\n        let (mut start_x, mut start_y) = (0, 0);\n        let mid = (n / 2) as usize;\n        let (mut offset, mut count) = (1, 1);\n        for _ in (0..(n / 2)).rev() {\n            let (mut i, mut j) = (start_x, start_y);\n\n            for _ in start_y..(n as usize - offset) {\n                result[start_x][j] = count;\n                count += 1;\n                j += 1;\n            }\n\n            for _ in start_x..(n as usize - offset) {\n                result[i][j] = count;\n                count += 1;\n                i += 1;\n            }\n\n            for _ in 0..(j - start_y) {\n                result[i][j] = count;\n                count += 1;\n                j -= 1;\n            }\n\n            for _ in 0..(i - start_x) {\n                result[i][j] = count;\n                count += 1;\n                i -= 1;\n            }\n\n            start_x += 1;\n            start_y += 1;\n            offset += 1;\n        }\n\n        if n % 2 &gt; 0 {\n            result[mid][mid] = count;\n        }\n        result\n    }\n}\n</code></pre>"},{"location":"algorithms/books/code_caprice/array/02array_algorithms/#42-\u76f8\u5173\u9898\u76ee","title":"4.2 \u76f8\u5173\u9898\u76ee","text":"<ul> <li> 54.\u87ba\u65cb\u77e9\u9635</li> <li> 59.\u87ba\u65cb\u77e9\u9635II</li> <li> \u5251\u6307Offer29.\u987a\u65f6\u9488\u6253\u5370\u77e9\u9635</li> </ul>"},{"location":"algorithms/books/code_caprice/linked_list/01basic/","title":"\u94fe\u8868\u7406\u8bba\u57fa\u7840","text":"<p>1. \u94fe\u8868\u7684\u5b9a\u4e49</p> <ul> <li>\u4e00\u79cd\u901a\u8fc7\u6307\u9488\u4e32\u8054\u5728\u4e00\u8d77\u7684\u7ebf\u6027\u7ed3\u6784</li> <li>\u6bcf\u4e00\u4e2a\u8282\u70b9\u7531\u4e24\u90e8\u5206\u7ec4\u6210\uff0c\u5206\u522b\u662f\u6570\u636e\u57df\u548c\u6307\u9488\u57df\uff08\u5b58\u653e\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u6307\u9488\uff09</li> <li>\u7b2c\u4e00\u4e2a\u8282\u70b9\u79f0\u4e3a\u94fe\u8868\u7684\u5934\u7ed3\u70b9\u5373 head\uff0c\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u7684\u6307\u9488\u57df\u6307\u5411\u7a7a\u6307\u9488</li> </ul> <p></p> <p>2. \u94fe\u8868\u7684\u7c7b\u578b</p> <ul> <li>\u5355\u94fe\u8868</li> </ul> <p>\u5982\u5b9a\u4e49\u6240\u793a\u3002</p> <ul> <li>\u53cc\u94fe\u8868</li> </ul> <p>\u6bcf\u4e00\u4e2a\u8282\u70b9\u6709\u4e24\u4e2a\u6307\u9488\u57df\uff0c\u53ef\u5206\u522b\u6307\u5411\u4e0a\u4e00\u4e2a\u8282\u70b9\u548c\u4e0b\u4e00\u4e2a\u8282\u70b9\u3002</p> <p>\u5373\u8bf4\u660e\u80fd\u505a\u5230\u5411\u524d\u67e5\u8be2\u548c\u5411\u540e\u67e5\u8be2\u3002</p> <p></p> <ul> <li>\u5faa\u73af\u94fe\u8868</li> </ul> <p>\u5373\u94fe\u8868\u9996\u5c3e\u662f\u76f8\u8fde\u7684\u3002\u53ef\u4ee5\u7528\u6765\u89e3\u51b3\u7ea6\u745f\u592b\u73af\u95ee\u9898\u3002</p> <p></p> <p>3. \u94fe\u8868\u7684\u5b58\u50a8\u65b9\u5f0f</p> <ul> <li>\u6570\u7ec4\u662f\u5728\u5185\u5b58\u4e2d\u662f\u8fde\u7eed\u5206\u5e03\u7684\uff0c\u4f46\u662f\u94fe\u8868\u5728\u5185\u5b58\u4e2d\u53ef\u4e0d\u662f\u8fde\u7eed\u5206\u5e03\u7684</li> <li>\u94fe\u8868\u662f\u901a\u8fc7\u6307\u9488\u57df\u7684\u6307\u9488\u94fe\u63a5\u5728\u5185\u5b58\u4e2d\u5404\u4e2a\u8282\u70b9\uff0c\u5373\u94fe\u8868\u4e2d\u7684\u8282\u70b9\u5728\u5185\u5b58\u4e2d\u4e0d\u662f\u8fde\u7eed\u5206\u5e03\u7684\uff0c\u800c\u662f\u6563\u4e71\u5206\u5e03\u5728\u5185\u5b58\u4e2d\u7684\u67d0\u5730\u5740\u4e0a</li> <li>\u5176\u5185\u5b58\u7684\u5206\u914d\u673a\u5236\u53d6\u51b3\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u7684\u5185\u5b58\u7ba1\u7406</li> </ul> <p></p> <p>4. \u94fe\u8868\u7684\u5b9a\u4e49</p> Go<pre><code>type ListNode struct {\n    Val  int\n    Next *ListNode\n}\n</code></pre> <p>5. \u94fe\u8868\u7684\u64cd\u4f5c</p> \u94fe\u8868\u64cd\u4f5c \u64cd\u4f5c\u7684\u89e3\u91ca \u5220\u9664\u8282\u70b9  \u6ce8\u610f\uff1a\u8282\u70b9\u7684\u5220\u9664\u5e76\u6ca1\u6709\u91ca\u653e\u88ab\u5220\u9664\u8282\u70b9\u7684\u5185\u5b58\u3002 \u6dfb\u52a0\u8282\u70b9 <p>6. \u6027\u80fd\u5206\u6790</p> \u63d2\u5165/\u5220\u9664 \u67e5\u8be2 \u9002\u7528\u573a\u666f \u6570\u7ec4 \\(O(n)\\) \\(O(1)\\) \u6570\u636e\u91cf\u56fa\u5b9a\uff0c\u9891\u7e41\u67e5\u8be2\uff0c\u8f83\u5c11\u589e\u5220 \u94fe\u8868 \\(O(1)\\) \\(O(n)\\) \u6570\u636e\u91cf\u4e0d\u56fa\u5b9a\uff0c\u9891\u7e41\u589e\u5220\uff0c\u8f83\u5c11\u67e5\u8be2"},{"location":"algorithms/books/code_caprice/linked_list/02list_algorithms/","title":"\u94fe\u8868\u7b97\u6cd5","text":""},{"location":"algorithms/books/code_caprice/linked_list/02list_algorithms/#1-\u79fb\u9664\u94fe\u8868\u5143\u7d20","title":"1. \u79fb\u9664\u94fe\u8868\u5143\u7d20","text":"<p>\u5bf9\u5e94 LeetCode \u9898\u76ee\uff1a</p> <p></p> <p>\u8fd9\u91cc\u5c31\u6d89\u53ca\u5230\u524d\u9762\u7406\u8bba\u90e8\u5206\u6240\u8bb2\u7684\u94fe\u8868\u7684\u5220\u9664\u64cd\u4f5c\u3002</p> <p>\u4f46\u662f\u5728\u5b9e\u9645\u7f16\u5199\u4ee3\u7801\u8fc7\u7a0b\u4e2d\u53ef\u53d1\u73b0\uff1a</p> <ul> <li>\u82e5\u76f4\u63a5\u91c7\u7528\u8282\u70b9 next \u6307\u9488\u76f4\u63a5\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u65b9\u5f0f</li> <li>\u5219\u5220\u9664\u5934\u90e8\u7ed3\u70b9\u548c\u5176\u4ed6\u7ed3\u70b9\u7684\u5904\u7406\u662f\u4e0d\u540c\u7684</li> </ul> <p>\u6240\u4ee5\u4e0b\u9762\u6211\u4eec\u671f\u671b\u901a\u8fc7\u4e00\u79cd\u65b9\u5f0f\u6765\u8ba9\u4e24\u79cd\u65b9\u5f0f\u7684\u5904\u7406\u4fdd\u6301\u4e00\u81f4\u3002</p>"},{"location":"algorithms/books/code_caprice/linked_list/02list_algorithms/#11-\u601d\u8def\u501f\u52a9\u865a\u62df\u5934\u7ed3\u70b9","title":"1.1 \u601d\u8def:\u501f\u52a9\u865a\u62df\u5934\u7ed3\u70b9","text":"<p>\u901a\u8fc7\u8bbe\u7f6e\u4e00\u4e2a\u865a\u62df\u5934\u7ed3\u70b9\uff0c\u8fd9\u6837\u539f\u94fe\u8868\u7684\u6240\u6709\u8282\u70b9\u5c31\u90fd\u53ef\u4ee5\u6309\u7167\u7edf\u4e00\u7684\u65b9\u5f0f\u8fdb\u884c\u79fb\u9664\u3002</p> <p></p> <p>\u6700\u540e\u5728\u8fd4\u56de\u5934\u7ed3\u70b9\u7684\u65f6\u5019\uff0c\u6ce8\u610f\u9700\u8981\u8fd4\u56de\u865a\u62df\u5934\u7ed3\u70b9\u7684 next\uff0c\u5177\u4f53\u4ee3\u7801\u5982\u4e0b\uff1a</p> <ul> <li>\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\\(O(n)\\)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6:\\(O(1)\\)</li> </ul> Go<pre><code>/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc removeElements(head *ListNode, val int) *ListNode {\n    dummyHead := &amp;ListNode{}\n    dummyHead.Next = head\n    cur := dummyHead\n    for cur != nil &amp;&amp; cur.Next != nil {\n        if cur.Next.Val == val {\n            cur.Next = cur.Next.Next\n        } else {\n            cur = cur.Next\n        }\n    }\n\n    return dummyHead.Next\n}\n</code></pre> Rust<pre><code>pub struct Solution;\n\n// Definition for singly-linked list.\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option&lt;Box&lt;ListNode&gt;&gt;,\n}\n\nimpl ListNode {\n    #[inline]\n    fn new(val: i32) -&gt; Self {\n        ListNode {\n            next: None,\n            val,\n        }\n    }\n}\n\nimpl Solution {\n    pub fn remove_elements(head: Option&lt;Box&lt;ListNode&gt;&gt;, val: i32) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {\n        let mut dummy_head = Box::new(ListNode::new(0));\n        dummy_head.next = head;\n        let mut cur = dummy_head.as_mut();\n        while let Some(nxt) = cur.next.take() {\n            if nxt.val == val {\n                cur.next = nxt.next;\n            } else {\n                cur.next = Some(nxt);\n                cur = cur.next.as_mut().unwrap();\n            }\n        }\n        dummy_head.next\n    }\n}\n</code></pre>"},{"location":"architecture/","title":"Architecture Design","text":""},{"location":"blog/","title":"Life","text":"<p>Hope to realize what I really want</p> <p>updated in 20231101</p> <ul> <li>\ud83d\udc68\u200d\ud83d\udcbb As a server engineer in Bytedance (202207-~)</li> <li>\ud83e\udee3 The most important thing at present is to maintain a stable mentality and return to the original intention</li> <li>\ud83e\udd15 Recently, the thing I have been learning is Rust And LangChain</li> <li>\u26a1 Always the self-reflection</li> </ul>"},{"location":"blog/#list-of-recently-read-books","title":"List of recently read books","text":"<p>See the doc</p>"},{"location":"blog/tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"common/","title":"Common","text":""},{"location":"ds/","title":"Data System","text":""},{"location":"language/","title":"Programming Language","text":"<p>Last update time: 20240203</p> <ul> <li> <p>Work mainly uses Golang</p> </li> <li> <p>Lately I\u2019ve been learning by using Rust</p> </li> <li> <p>Programming languages that have actually been exposed to (and used) include the following</p> <ul> <li>Java</li> <li>Python</li> <li>C/C++</li> <li>Html/Css/Javascript</li> <li>Kotlin .......</li> </ul> </li> </ul>"},{"location":"language/golang/","title":"Golang","text":""},{"location":"language/rust/","title":"Rust","text":""},{"location":"middleware/","title":"Middleware","text":""},{"location":"network/","title":"Computer Network","text":""},{"location":"os/","title":"Operating System","text":""},{"location":"os/mit6s081/","title":"MIT-6.S081","text":"<ul> <li>\u8bfe\u7a0b\u8868\uff1ahttps://pdos.csail.mit.edu/6.1810/2020/schedule.html</li> <li>\u8bfe\u7a0b\u89c6\u9891\uff1ahttps://www.youtube.com/watch?v=L6YqHxYHa7A</li> <li>\u7ffb\u8bd1\u8bfe\u7a0b\u6587\u6863\uff1ahttps://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/</li> <li>\u5176\u4ed6\u53c2\u8003\u4fe1\u606f\uff1a<ul> <li>https://zhuanlan.zhihu.com/p/632281381</li> <li>https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/#_1</li> <li>https://tarplkpqsm.feishu.cn/docs/doccnBFsXFMsAr1oXEVsaT9E3Jg#</li> </ul> </li> </ul>"},{"location":"os/mit6s081/#lecture--preparation","title":"Lecture &amp; Preparation","text":"<ul> <li> Lecture 01 </li> <li> Lecture 02</li> <li> Lecture 03</li> <li> Lecture 04</li> <li> Lecture 05</li> <li> Lecture 06</li> <li> Lecture 07</li> <li> Lecture 08</li> <li> Lecture 09</li> <li> Lecture 10</li> <li> Lecture 11</li> <li> Lecture 12</li> <li> Lecture 13</li> <li> Lecture 14</li> <li> Lecture 15</li> <li> Lecture 16</li> <li> Lecture 17</li> <li> Lecture 18</li> <li> Lecture 19</li> <li> Lecture 20</li> <li> Lecture 21</li> <li> Lecture 22</li> <li> Lecture 23</li> </ul>"},{"location":"os/mit6s081/#lab","title":"Lab","text":"<ul> <li> Lab01</li> <li> Lab02</li> <li> Lab03</li> <li> Lab04</li> <li> Lab05</li> <li> Lab06</li> <li> Lab07</li> <li> Lab08</li> <li> Lab09</li> <li> Lab10</li> <li> Lab11</li> </ul>"},{"location":"os/mit6s081/labs/lab1/","title":"Lab: Xv6 and Unix utilities","text":"<p>https://pdos.csail.mit.edu/6.1810/2023/labs/util.html</p>"},{"location":"os/mit6s081/labs/lab1/#0-macos-environments","title":"0. MacOs Environments","text":"<p>For this class we'll need the RISC-V versions of a couple different tools: QEMU 5.1+, GDB 8.3+, GCC, and Binutils.</p> <p>Previously installed corresponding programs can be omitted by yourself.</p> <ul> <li>First, install developer tools:</li> </ul> Bash<pre><code>xcode-select --install\n</code></pre> <ul> <li>Next, install Homebrew, a package manager for macOS:</li> </ul> Bash<pre><code>$ /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <ul> <li>Next, install the RISC-V compiler toolchain:</li> </ul> Bash<pre><code>$ brew tap riscv/riscv\n$ brew install riscv-tools\n</code></pre> <ul> <li>The brew formula may not link into /usr/local. You will need to update your shell's rc file (e.g. ~/.bashrc) to add the appropriate directory to $PATH.</li> </ul> Bash<pre><code>PATH=$PATH:/usr/local/opt/riscv-gnu-toolchain/bin\n</code></pre> <ul> <li>Finally, install QEMU:</li> </ul> Bash<pre><code>brew install qemu\n</code></pre> <ul> <li>Testing your Installation:</li> </ul> Bash<pre><code>$ qemu-system-riscv64 --version\nQEMU emulator version 5.1.0\n$ riscv64-unknown-elf-gcc --version\nriscv64-unknown-elf-gcc (GCC) 10.1.0\n...\n</code></pre> <p></p> <p></p>"},{"location":"os/mit6s081/labs/lab1/#1-boot-xv6","title":"1. Boot xv6","text":"<ul> <li>Fetch the git repository for the xv6 source for the lab:</li> </ul> Bash<pre><code>$ git clone git://g.csail.mit.edu/xv6-labs-2023\nCloning into 'xv6-labs-2023'...\n...\n$ cd xv6-labs-2023\n</code></pre> <ul> <li>Build and run xv6:</li> </ul> Bash<pre><code>$ make qemu\nriscv64-unknown-elf-gcc    -c -o kernel/entry.o kernel/entry.S\nriscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie   -c -o kernel/start.o kernel/start.c\n...\nriscv64-unknown-elf-ld -z max-page-size=4096 -N -e main -Ttext 0 -o user/_zombie user/zombie.o user/ulib.o user/usys.o user/printf.o user/umalloc.o\nriscv64-unknown-elf-objdump -S user/_zombie &gt; user/zombie.asm\nriscv64-unknown-elf-objdump -t user/_zombie | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$/d' &gt; user/zombie.sym\nmkfs/mkfs fs.img README  user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie\nnmeta 46 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 1) blocks 954 total 1000\nballoc: first 591 blocks have been allocated\nballoc: write bitmap block at sector 45\nqemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0\n\nxv6 kernel is booting\n\nhart 2 starting\nhart 1 starting\ninit: starting sh\n</code></pre> <ul> <li>xv6 has no ps command, but, if you type <code>Ctrl-p</code>, the kernel will print information about each process.<ul> <li>If you try it now, you'll see two lines: one for init, and one for <code>sh</code>. </li> </ul> </li> </ul> <ul> <li>To quit qemu type: <code>Ctrl-a x</code> (press <code>Ctrl</code> and <code>a</code> at the same time, followed by x).</li> </ul>"},{"location":"os/mit6s081/labs/lab1/#2-sleep","title":"2. sleep","text":"<ul> <li>Implement a user-level sleep program for xv6, along the lines of the UNIX sleep command. Your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file user/sleep.c.</li> </ul> C<pre><code>#include \"kernel/types.h\"\n#include \"user/user.h\"\n\nint main(int argc, char *argv[]) {\n  if (argc != 2) {\n    fprintf(2, \"usage: sleep [ticks num]\\n\");\n    exit(1);\n  }\n  // atoi sys call guarantees return an integer\n  int ticks = atoi(argv[1]);\n  int ret = sleep(ticks);\n  exit(ret);\n}\n</code></pre>"},{"location":"os/mit6s081/notes/lec1/","title":"Lec1","text":""},{"location":"os/mit6s081/notes/lec1/#1-preparationoperator-system-interfaces","title":"1. Preparation:Operator system interfaces","text":"<p>book-riscv-rev3 Chapter1</p> <p></p>"},{"location":"os/mit6s081/notes/lec1/#11-processes-and-memory","title":"1.1 Processes and memory","text":"<ul> <li>An xv6 process consists of user-space memory (instructions, data, and stack) and per-process state private to the kernel.</li> <li>A process may create a new process using the <code>fork</code> system call.</li> </ul> <ul> <li>If <code>exec</code> succeeds then the child will execute instructions from <code>echo</code> instead of <code>runcmd</code>. At some point <code>echo</code> will call <code>exit</code>, which will cause the parent to return from <code>wait</code> in <code>main</code> (user/sh.c:146).</li> <li>why <code>fork</code> and <code>exec</code> are not combined in a single call; we will see later that the shell exploits the separation in its implementation of I/O redirection. To avoid the wastefulness of creating a duplicate process and then immediately replacing it (with <code>exec</code>), operating kernels optimize the implementation of <code>fork</code> for this use case by using virtual memory techniques such as copy-on-write (see Section 4.6).</li> <li>Xv6 allocates most user-space memory implicitly.</li> </ul>"},{"location":"os/mit6s081/notes/lec1/#12-io-and-file-descriptors","title":"1.2 I/O and File descriptors","text":"<ul> <li>A file descriptor is a small integer representing a kernel-managed object that a process may read from or write to.</li> <li>the file descriptor interface abstracts away the differences between files, pipes, and devices, making them all look like streams of bytes. We\u2019ll refer to input and output as I/O.</li> <li>By convention, a process reads from file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), and writes error messages to file descriptor 2 (standard error).<ul> <li>the shell exploits the convention to implement I/O redirection and pipelines. The shell ensures that it always has three file descriptors open (user/sh.c:152), which are by default file descriptors for the console.</li> </ul> </li> <li>The <code>read</code> and <code>write</code> system calls read bytes from and write bytes to open files named by file descriptors.</li> <li>The use of file descriptors and the convention that file descriptor 0 is input and file descriptor 1 is output allows a simple implementation of <code>cat</code>.</li> <li>A newly allocated file descriptor is always the lowest-numbered unused descriptor of the current process.</li> <li>The system call <code>exec</code> replaces the calling process\u2019s memory but preserves its file table. This behavior allows the shell to implement I/O redirection by forking, re-opening chosen file descriptors in the child, and then calling <code>exec</code> to run the new program.</li> <li>The parent process\u2019s file descriptors are not changed by this sequence, since it modifies only the child\u2019s descriptors.</li> <li>The second argument to <code>open</code> consists of a set of flags, expressed as bits, that control what <code>open</code> does.<ul> <li>like:open(\"input.txt\", O_RDONLY)</li> </ul> </li> <li>Now it should be clear why it is helpful that <code>fork</code> and <code>exec</code> are separate calls: between the two, the shell has a chance to redirect the child\u2019s I/O without disturbing the I/O setup of the main shell.</li> <li>Although <code>fork</code> copies the file descriptor table, each underlying file offset is shared between parent and child.</li> <li>The <code>dup</code> system call duplicates an existing file descriptor, returning a new one that refers to the same underlying I/O object. Both file descriptors share an offset, just as the file descriptors duplicated by <code>fork</code> do.</li> <li>a process writing to file descriptor 1 may be writing to a file, to a device like the console, or to a pipe.</li> </ul>"},{"location":"os/mit6s081/notes/lec1/#13-pipe","title":"1.3 Pipe","text":"<ul> <li>A pipe is a small kernel buffer exposed to processes as a pair of file descriptors, one for reading and one for writing. Writing data to one end of the pipe makes that data available for reading from the other end of the pipe. Pipes provide a way for processes to communicate.</li> </ul> <ul> <li>If no data is available, a <code>read</code> on a pipe waits for either data to be written or for all file descriptors referring to the write end to be closed.</li> <li>The fact that <code>read</code> blocks until it is impossible for new data to arrive is one reason that it\u2019s important for the child to close the write end of the pipe before executing wc above</li> <li>(e.g., <code>a | b | c</code>) the shell may create a tree of processes.</li> <li>Pipes may seem no more powerful than temporary files: the pipeline<ul> <li><code>echo hello world | wc</code> could be implemented without pipes as <code>echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyz</code></li> </ul> </li> <li>Pipes have at least three advantages over temporary files in this situation.<ul> <li>First, pipes automatically clean themselves up; with the file redirection, a shell would have to be careful to remove <code>/tmp/xyz</code> when done.</li> <li>Second, pipes can pass arbitrarily long streams of data, while file redirection requires enough free space on disk to store all the data.</li> <li>Third, pipes allow for parallel execution of pipeline stages, while the file approach requires the first program to finish before the second starts.</li> </ul> </li> </ul>"},{"location":"os/mit6s081/notes/lec1/#14-file-system","title":"1.4 File System","text":"<ul> <li>The xv6 file system provides data files, which contain uninterpreted byte arrays, and directories, which contain named references to data files and other directories.<ul> <li>The directories form a tree, starting at a special directory called the root. </li> <li>Paths that don\u2019t begin with / are evaluated relative to the calling process\u2019s current directory, which can be changed with the chdir system call.</li> </ul> </li> </ul> <ul> <li>There are system calls to create new files and directories: <ul> <li><code>mkdir</code> creates a new directory</li> <li><code>open</code> with the O_CREATE flag creates a new data file</li> <li><code>mknod</code> creates a new device file</li> </ul> </li> </ul> <ul> <li><code>mknod</code> creates a special file that refers to a device. Associated with a device file are the major and minor device numbers (the two arguments to <code>mknod</code>), which uniquely identify a kernel device.<ul> <li>When a process later opens a device file, the kernel diverts <code>read</code> and <code>write</code> system calls to the kernel device implementation instead of passing them to the file system.</li> </ul> </li> <li>Each link consists of an entry in a directory; the entry contains a file name and a reference to an inode.<ul> <li>An inode holds metadata about a file, including its type (file or directory or device), its length, the location of the file\u2019s content on disk, and the number of links to a file.</li> </ul> </li> <li>The <code>fstat</code> system call retrieves information from the inode that a file descriptor refers to.</li> </ul> <ul> <li>The <code>link</code> system call creates another file system name referring to the same inode as an existing file.<ul> <li>Each inode is identified by a unique inode number.</li> <li>After the code sequence above, it is possible to determine that a and b refer to the same underlying contents by inspecting the result of fstat: both will return the same inode number (<code>ino</code>), and the <code>nlink</code> count will be set to 2. </li> </ul> </li> </ul> C<pre><code>open(\"a\", O_CREATE|O_WRONLY);\nlink(\"a\", \"b\");\n</code></pre> <ul> <li>an idiomatic way to create a temporary inode with no name that will be cleaned up when the process closes <code>fd</code> or exits.</li> </ul> C<pre><code>fd = open(\"/tmp/xyz\", O_CREATE|O_RDWR);\nunlink(\"/tmp/xyz\");\n</code></pre> <ul> <li>Unix provides file utilities callable from the shell as user-level programs.</li> <li><code>cd</code> must change the current working directory of the shell itself.</li> </ul>"},{"location":"os/mit6s081/notes/lec1/#15-real-world","title":"1.5 Real World","text":"<ul> <li>Unix\u2019s combination of \u201cstandard\u201d file descriptors, pipes, and convenient shell syntax for operations on them was a major advance in writing general-purpose reusable programs.<ul> <li>The idea sparked a culture of \u201csoftware tools\u201d that was responsible for much of Unix\u2019s power and popularity, and the shell was the first so-called \u201cscripting language.\u201d</li> </ul> </li> <li>The Unix system call interface has been standardized through the Portable Operating System Interface (POSIX) standard.<ul> <li>Our main goals for xv6 are simplicity and clarity while providing a simple UNIX-like system-call interface.</li> </ul> </li> <li>Unix unified access to multiple types of resources (files, directories, and devices) with a single set of file-name and file-descriptor interfaces.<ul> <li>This idea can be extended to more kinds of resources.</li> </ul> </li> <li>The file system and file descriptors have been powerful abstractions. Even so, there are other models for operating system interfaces.<ul> <li>Multics, a predecessor of Unix, abstracted file storage in a way that made it look like memory, producing a very different flavor of interface. The complexity of the Multics design had a direct influence on the designers of Unix, who aimed to build something simpler.</li> </ul> </li> <li>Any operating system must multiplex processes onto the underlying hardware, isolate processes from each other, and provide mechanisms for controlled inter-process communication.</li> </ul>"},{"location":"os/mit6s081/notes/lec1/#2-lecture-1","title":"2. Lecture 1","text":"<p>https://pdos.csail.mit.edu/6.1810/2023/lec/l-overview.txt</p>"},{"location":"os/mit6s081/notes/lec1/#21-operating-system-introduction","title":"2.1 operating system introduction","text":"<ul> <li> <p>What's an operating system?</p> <ul> <li>[user/kernel diagram]</li> <li>h/w: CPU, RAM, disk, net, &amp;c</li> <li>user applications: sh, cc, DB, &amp;c</li> <li>kernel services: FS, processes, memory, network, &amp;c</li> <li>system calls</li> </ul> </li> <li> <p>What is the purpose of an O/S?</p> <ul> <li>Multiplex the hardware among many applications</li> <li>Isolate applications for security and to contain bugs</li> <li>Allow sharing among cooperating applications</li> <li>Abstract the hardware for portability</li> <li>Provide useful services</li> </ul> </li> <li> <p>Design tensions make O/S design interesting</p> <ul> <li>efficient vs abstract/portable/general-purpose</li> <li>powerful vs simple interfaces</li> <li>flexible vs secure</li> <li>compatible vs new hardware and interfaces</li> </ul> </li> </ul>"},{"location":"os/mit6s081/notes/lec1/#22-unix-system-calls","title":"2.2 UNIX system calls","text":""},{"location":"os/mit6s081/notes/lec1/#221-example-ex1c-copy-input-to-output","title":"2.2.1 example: ex1.c, copy input to output","text":"C<pre><code>// ex1.c: copy input to output.\n#include \"kernel/types.h\"\n#include \"user/user.h\"\n\nint main()\n{\n  char buf[64];\n  while(1){\n    int n = read(0, buf, sizeof(buf));\n    if(n &lt;= 0)\n      break;\n    write(1, buf, n);\n  }\n  exit(0);\n}\n</code></pre> <ul> <li>read() and write() are system calls<ul> <li>they look like function calls, but actually jump into the kernel.</li> </ul> </li> <li>first read()/write() argument is a \"file descriptor\" (FD)<ul> <li>passed to kernel to tell it which \"open file\" to read/write </li> <li>must previously have been opened </li> <li>an FD connects to a file/pipe/socket/&amp;c </li> <li>a process can open many files, have many FDs</li> </ul> </li> </ul> <p>UNIX convention: fd 0 is \"standard input\", 1 is \"standard output\"</p> <ul> <li>programs don't have to know where input comes from, or output goes </li> <li>they can just read/write FDs 0 and 1</li> </ul> <ul> <li>second read() argument is a pointer to some memory into which to read</li> <li>third argument is the number of bytes to read<ul> <li>read() may read less, but not more</li> </ul> </li> <li>return value: number of bytes actually read, or -1 for error</li> <li>note: ex1.c does not care about the format of the data <ul> <li>UNIX I/O is 8-bit bytes </li> <li>interpretation is application-specific, e.g. database records, C source, &amp;c</li> </ul> </li> </ul> <p>where do file descriptors come from?</p> <p>answer:</p> <p>File descriptors are integer values that are used to identify and access files or other input/output resources within a computer operating system. In Unix-like operating systems, including Linux, file descriptors are typically obtained through the process of opening files, pipes, sockets, and other resources. </p> <p>The steps and thought process for obtaining file descriptors are as follows:</p> <ol> <li>Open System Call: File descriptors are typically obtained through the use of system calls such as <code>open()</code> for files, <code>socket()</code> for network sockets, or <code>pipe()</code> for inter-process communication pipes. When a file or resource is opened, the operating system returns a file descriptor that can be used to reference that resource in subsequent read or write operations.</li> <li>Assignment: Once obtained from the system call, the file descriptor is typically assigned to a variable in the program for later use. For example, after opening a file, the returned file descriptor might be stored in an integer variable for easy reference.</li> <li>Use in I/O Operations: The obtained file descriptor is then used in read and write operations to perform input and output on the associated resource. For example, the file descriptor might be passed as an argument to the <code>read()</code> or <code>write()</code> system calls to read from or write to the associated file, pipe, or socket.</li> <li>Closing: After the file descriptor is no longer needed, it should be closed using the <code>close()</code> system call. This releases the associated resources and frees up the file descriptor for reuse. </li> </ol> <p>In summary, file descriptors are obtained through system calls when opening files or other resources, and they serve as references to those resources for performing input/output operations within a program.</p>"},{"location":"os/mit6s081/notes/lec1/#222-example-ex2c-create-a-file","title":"2.2.2 example: ex2.c, create a file","text":"C<pre><code>// ex2.c: create a file, write to it.\n\n#include \"kernel/types.h\"\n#include \"user/user.h\"\n#include \"kernel/fcntl.h\"\n\nint main()\n{\n  int fd = open(\"out\", O_WRONLY | O_CREATE | O_TRUNC);\n\n  printf(\"open returned fd %d\\n\", fd);\n\n  write(fd, \"ooo\\n\", 4);\n\n  exit(0);\n}\n</code></pre> <ul> <li>open() creates (or opens) a file, returns a file descriptor (or -1 for error)</li> <li>FD is a small integer </li> <li>FD indexes into a per-process table maintained by kernel</li> <li>different processes have different FD name-spaces <ul> <li>e.g. FD 3 usually means different things to different processes</li> </ul> </li> </ul> <p>what happens when a program calls a system call like open()?</p> <ul> <li>CPU saves some user registers</li> <li>CPU increases privilege level</li> <li>CPU jumps to a known \"entry point\" in the kernel</li> <li>now running C code in the kernel</li> <li>kernel calls system call implementation<ul> <li>sys_open() looks up name in file system </li> <li>it might wait for the disk </li> <li>it updates kernel data structures (file block cache, FD table)</li> </ul> </li> <li>restore user registers</li> <li>reduce privilege level</li> <li>jump back to calling point in the program, which resumes</li> </ul> <ul> <li>typing to UNIX's command-line interface, the shell<ul> <li>the shell is an ordinary user program, not part of the kernel</li> <li>the shell lets you run UNIX command-line utilities</li> <li>time-sharing via the shell was the original focus of UNIX</li> </ul> </li> </ul>"},{"location":"os/mit6s081/notes/lec1/#223-example-ex3c-create-a-new-process","title":"2.2.3 example: ex3.c, create a new process","text":"C<pre><code>// ex3.c: create a new process with fork()\n#include \"kernel/types.h\"\n#include \"user/user.h\"\nint main()\n{\n  int pid;\n  pid = fork();\n  printf(\"fork() returned %d\\n\", pid);\n  if(pid == 0){\n    printf(\"child\\n\");\n  } else {\n    printf(\"parent\\n\");\n  }\n  exit(0);\n}\n</code></pre> <ul> <li>a separate process helps prevent them from interfering, e.g. if buggy </li> <li>the fork() system call creates a new process </li> <li>the kernel makes a copy of the calling process<ul> <li>instructions, data, registers, file descriptors, current directory</li> <li>\"parent\" and \"child\" processes</li> </ul> </li> <li>child and parent are initially identical!<ul> <li>except: fork() returns a pid in parent, 0 in child</li> </ul> </li> <li>a pid (process ID) is an integer; kernel gives each process a different pid</li> </ul>"},{"location":"os/mit6s081/notes/lec1/#224-example-ex4c-replace-calling-process-with-an-executable-file","title":"2.2.4 example: ex4.c, replace calling process with an executable file","text":"C<pre><code>// ex4.c: replace a process with an executable file\n\n#include \"kernel/types.h\"\n#include \"user/user.h\"\nint main()\n{\n  char *argv[] = { \"echo\", \"this\", \"is\", \"echo\", 0 };\n  exec(\"echo\", argv);\n  printf(\"exec failed!\\n\");\n  exit(0);\n}\n</code></pre> <p>how does the shell run a program, e.g. $ echo a b c</p> <ul> <li>a program is stored in a file: instructions and initial memory<ul> <li>created by the compiler and linker</li> </ul> </li> <li>so there's a file called echo, containing instructions<ul> <li>on your own computer: ls -l /bin/echo</li> </ul> </li> <li>exec() replaces current process with an executable file <ul> <li>discards old instruction and data memory </li> <li>loads instructions and initial memory from the file </li> <li>preserves file descriptors</li> </ul> </li> </ul>"},{"location":"os/mit6s081/notes/lec1/#225-example-ex5c-fork-a-new-process-exec-a-program","title":"2.2.5 example: ex5.c, fork() a new process, exec() a program","text":"C<pre><code>#include \"kernel/types.h\"\n#include \"user/user.h\"\n// ex5.c: fork then exec\nint main()\n{\n  int pid, status;\n  pid = fork();\n  if(pid == 0){\n    char *argv[] = { \"echo\", \"THIS\", \"IS\", \"ECHO\", 0 };\n    exec(\"echo\", argv);\n    printf(\"exec failed!\\n\");\n    exit(1);\n  } else {\n    printf(\"parent waiting\\n\");\n    wait(&amp;status);\n    printf(\"the child exited with status %d\\n\", status);\n  }\n\n  exit(0);\n}\n</code></pre> <ul> <li>the shell can't simply call exec()!<ul> <li>since it wouldn't be running any more </li> <li>wouldn't be able to accept more than one command</li> </ul> </li> <li>ex5.c shows how the shell deals with this:<ul> <li>fork() a child process </li> <li>child calls exec()</li> <li>parent wait()s for child to finish</li> </ul> </li> <li>the shell does this fork/exec/wait for every command you type <ul> <li>after wait(), the shell prints the next prompt</li> </ul> </li> <li>exit(status) -&gt; wait(&amp;status)<ul> <li>status allows children to send back 32 bits of info to parent </li> <li>status convention: 0 = success, 1 = command encountered an error</li> </ul> </li> <li>note: the fork() copies, but exec() discards the copied memory<ul> <li>this may seem wasteful, you'll transparently eliminate the copy in the \"copy-on-write\" lab</li> </ul> </li> </ul>"},{"location":"os/mit6s081/notes/lec1/#226-example-ex6c-redirect-the-output-of-a-command","title":"2.2.6 example: ex6.c, redirect the output of a command","text":"C<pre><code>#include \"kernel/types.h\"\n#include \"user/user.h\"\n#include \"kernel/fcntl.h\"\n// ex6.c: run a command with output redirected\nint main()\n{\n  int pid;\n  pid = fork();\n  if(pid == 0){\n    close(1);\n    open(\"out\", O_WRONLY | O_CREATE | O_TRUNC);\n\n    char *argv[] = { \"echo\", \"this\", \"is\", \"redirected\", \"echo\", 0 };\n    exec(\"echo\", argv);\n    printf(\"exec failed!\\n\");\n    exit(1);\n  } else {\n    wait((int *) 0);\n  }\n\n  exit(0);\n}\n</code></pre> <ul> <li>what does the shell do for this? </li> <li>$ echo hello &gt; out </li> <li>answer: fork, child changes FD 1, child exec's echo</li> <li>note: open() always chooses lowest unused FD; 1 due to close(1). </li> <li>note: exec preserves FDs </li> <li>fork, FDs, and exec interact nicely to implement I/O redirection <ul> <li>separate fork-then-exec gives child a chance to change FDs </li> <li>before exec() gives up control </li> <li>and without disturbing parent's FDs</li> </ul> </li> <li>FDs provide indirection <ul> <li>commands just use FDs 0 and 1, don't have to know where they go</li> </ul> </li> </ul>"},{"location":"os/mit6s081/notes/lec1/#227-example-ex7c-communicate-through-a-pipe","title":"2.2.7 example: ex7.c, communicate through a pipe","text":"C<pre><code>// ex7.c: communication over a pipe\n#include \"kernel/types.h\"\n#include \"user/user.h\"\nint main()\n{\n  int fds[2];\n  char buf[100];\n  int n;\n\n  // create a pipe, with two FDs in fds[0], fds[1].\n  pipe(fds);\n\n  // write to the pipe\n  write(fds[1], \"xyz\\n\", 4);\n\n  // read from the pipe\n  n = read(fds[0], buf, sizeof(buf));\n\n  // display the results on the terminal\n  write(1, buf, n);\n\n  exit(0);\n}\n</code></pre> <ul> <li>an FD can refer to a \"pipe\", rather than a file </li> <li>the pipe() system call creates two FDs <ul> <li>read from the first FD </li> <li>write to the second FD</li> </ul> </li> <li>the kernel maintains a buffer for each pipe<ul> <li>write() appends to the buffer </li> <li>read() waits until there is data</li> </ul> </li> </ul>"},{"location":"os/mit6s081/notes/lec1/#228-example-ex8c-communicate-between-processes","title":"2.2.8 example: ex8.c, communicate between processes","text":"C<pre><code>#include \"kernel/types.h\"\n#include \"user/user.h\"\n// ex8.c: communication between two processes\nint main()\n{\n  int n, pid;\n  int fds[2];\n  char buf[100];\n\n  // create a pipe, with two FDs in fds[0], fds[1].\n  pipe(fds);\n\n  pid = fork();\n  if (pid == 0) {\n    // child\n    write(fds[1], \"this is ex8\\n\", 12);\n  } else {\n    // parent\n    n = read(fds[0], buf, sizeof(buf));\n    write(1, buf, n);\n  }\n\n  exit(0);\n}\n</code></pre> <ul> <li>the shell builds pipelines by forking twice and calling exec()</li> <li>pipes are a separate abstraction, but combine well w/ fork()</li> </ul>"},{"location":"os/mit6s081/notes/lec1/#229-example-ex9c-list-files-in-a-directory","title":"2.2.9 example: ex9.c, list files in a directory","text":"C<pre><code>#include \"kernel/types.h\"\n#include \"user/user.h\"\n\n// ex9.c: list file names in the current directory\n\nstruct dirent {\n  ushort inum;\n  char name[14];\n};\n\nint main()\n{\n  int fd;\n  struct dirent e;\n\n  fd = open(\".\", 0);\n  while(read(fd, &amp;e, sizeof(e)) == sizeof(e)){\n    if(e.name[0] != '\\0'){\n      printf(\"%s\\n\", e.name);\n    }\n  }\n  exit(0);\n}\n</code></pre>"},{"location":"os/mit6s081/notes/lec2/","title":"Lec2","text":""},{"location":"os/mit6s081/notes/lec2/#1-preparationoperating-system-organization","title":"1. Preparation:Operating system organization","text":"<p>book-riscv-rev3 Chapter2</p>"},{"location":"os/mit6s081/notes/lec2/#2-lecture-2","title":"2. Lecture 2","text":""},{"location":"project/","title":"Project Engineering","text":""},{"location":"blog/tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"}]}